# NewbornAI 2.0 MCPデータフィルタリング戦略仕様書

## 概要

MCPサーバー接続時の記憶データ保護を目的とした、段階的データフィルタリング戦略です。サービス特性に応じた適切なデータ共有レベルを実現します。

## MCPサーバー分類システム

### 1. サービス分類フレームワーク

```python
from enum import Enum
from typing import Dict, Any, List, Optional, Set
from dataclasses import dataclass
import re
import json

class MCPServiceCategory(Enum):
    \"\"\"MCPサービスカテゴリ\"\"\"\n    LOCAL_VISUALIZATION = \"local_visualization\"     # ローカル可視化\n    LOCAL_ANALYSIS = \"local_analysis\"               # ローカル分析\n    CREATIVE_TOOLS = \"creative_tools\"               # 創造的ツール\n    EXTERNAL_API = \"external_api\"                   # 外部API\n    CLOUD_SERVICE = \"cloud_service\"                 # クラウドサービス\n    UNKNOWN_EXTERNAL = \"unknown_external\"           # 不明な外部サービス\n\nclass DataRequirement(Enum):\n    \"\"\"データ要求レベル\"\"\"\n    MINIMAL = \"minimal\"           # 最小限（φ値概要のみ）\n    BASIC = \"basic\"               # 基本（段階・φ値詳細）\n    ENHANCED = \"enhanced\"         # 拡張（体験サマリー含む）\n    COMPREHENSIVE = \"comprehensive\"  # 包括的（制限付き記憶アクセス）\n    FULL_ACCESS = \"full_access\"   # 完全アクセス（ローカルのみ）\n\n@dataclass\nclass MCPServiceProfile:\n    \"\"\"MCPサービスプロファイル\"\"\"\n    name: str\n    category: MCPServiceCategory\n    data_requirement: DataRequirement\n    trusted_domains: Set[str]\n    max_data_age_hours: Optional[int]  # データの最大年齢\n    allowed_data_types: Set[str]\n    prohibited_data_types: Set[str]\n    requires_user_consent: bool\n    anonymization_required: bool\n    \nclass MCPServiceClassifier:\n    \"\"\"MCPサービス分類器\"\"\"\n    \n    def __init__(self):\n        self.service_profiles: Dict[str, MCPServiceProfile] = {}\n        self.domain_patterns = {\n            # ローカルサービス\n            r'^(localhost|127\\.0\\.0\\.1|0\\.0\\.0\\.0)': MCPServiceCategory.LOCAL_VISUALIZATION,\n            \n            # 創造的ツール\n            r'(photoshop|blender|unity|touchdesigner|max|ableton)': MCPServiceCategory.CREATIVE_TOOLS,\n            \n            # 外部API\n            r'(openai\\.com|anthropic\\.com|api\\.)': MCPServiceCategory.EXTERNAL_API,\n            \n            # クラウドサービス\n            r'(github\\.com|slack\\.com|notion\\.so|discord\\.com)': MCPServiceCategory.CLOUD_SERVICE,\n        }\n        \n        self.initialize_default_profiles()\n        \n    def initialize_default_profiles(self):\n        \"\"\"デフォルトプロファイル初期化\"\"\"\n        \n        # ローカル可視化サービス\n        self.service_profiles['localhost_visualization'] = MCPServiceProfile(\n            name='localhost_visualization',\n            category=MCPServiceCategory.LOCAL_VISUALIZATION,\n            data_requirement=DataRequirement.COMPREHENSIVE,\n            trusted_domains={'localhost', '127.0.0.1'},\n            max_data_age_hours=None,\n            allowed_data_types={'phi_values', 'stage_info', 'visual_data', 'temporal_patterns'},\n            prohibited_data_types={'personal_memories', 'detailed_experiences'},\n            requires_user_consent=False,\n            anonymization_required=False\n        )\n        \n        # 創造的ツール\n        self.service_profiles['creative_tools'] = MCPServiceProfile(\n            name='creative_tools',\n            category=MCPServiceCategory.CREATIVE_TOOLS,\n            data_requirement=DataRequirement.ENHANCED,\n            trusted_domains=set(),\n            max_data_age_hours=1,  # 1時間以内のデータのみ\n            allowed_data_types={'phi_summary', 'stage_level', 'visual_cues', 'creative_inspiration'},\n            prohibited_data_types={'detailed_memories', 'personal_data', 'temporal_consciousness'},\n            requires_user_consent=True,\n            anonymization_required=True\n        )\n        \n        # 外部API\n        self.service_profiles['external_api'] = MCPServiceProfile(\n            name='external_api',\n            category=MCPServiceCategory.EXTERNAL_API,\n            data_requirement=DataRequirement.MINIMAL,\n            trusted_domains=set(),\n            max_data_age_hours=None,\n            allowed_data_types={'phi_summary', 'stage_level'},\n            prohibited_data_types={'memories', 'experiences', 'temporal_data', 'personal_info'},\n            requires_user_consent=True,\n            anonymization_required=True\n        )\n        \n    def classify_service(self, service_name: str, service_url: str = '') -> MCPServiceProfile:\n        \"\"\"サービス分類\"\"\"\n        \n        # 既知のプロファイルがあるかチェック\n        if service_name in self.service_profiles:\n            return self.service_profiles[service_name]\n            \n        # URLパターンマッチング\n        for pattern, category in self.domain_patterns.items():\n            if re.search(pattern, service_url.lower()) or re.search(pattern, service_name.lower()):\n                return self.get_category_default_profile(category)\n                \n        # 不明な外部サービスとして扱う\n        return self.get_category_default_profile(MCPServiceCategory.UNKNOWN_EXTERNAL)\n        \n    def get_category_default_profile(self, category: MCPServiceCategory) -> MCPServiceProfile:\n        \"\"\"カテゴリ別デフォルトプロファイル取得\"\"\"\n        \n        defaults = {\n            MCPServiceCategory.LOCAL_VISUALIZATION: self.service_profiles['localhost_visualization'],\n            MCPServiceCategory.CREATIVE_TOOLS: self.service_profiles['creative_tools'],\n            MCPServiceCategory.EXTERNAL_API: self.service_profiles['external_api'],\n        }\n        \n        return defaults.get(category, self.service_profiles['external_api'])\n```\n\n### 2. 段階的データフィルタリング\n\n```python\nimport time\nfrom typing import Union\nimport hashlib\n\nclass ConsciousnessDataProcessor:\n    \"\"\"意識データ処理\"\"\"\n    \n    def __init__(self, classifier: MCPServiceClassifier):\n        self.classifier = classifier\n        self.anonymization_cache: Dict[str, str] = {}\n        \n    def process_for_service(\n        self,\n        consciousness_data: Dict[str, Any],\n        service_name: str,\n        service_url: str = ''\n    ) -> Dict[str, Any]:\n        \"\"\"サービス向けデータ処理\"\"\"\n        \n        # サービス分類\n        profile = self.classifier.classify_service(service_name, service_url)\n        \n        # データ年齢チェック\n        if not self.is_data_fresh_enough(consciousness_data, profile):\n            return {}\n            \n        # データ要求レベル別処理\n        if profile.data_requirement == DataRequirement.MINIMAL:\n            return self.extract_minimal_data(consciousness_data, profile)\n        elif profile.data_requirement == DataRequirement.BASIC:\n            return self.extract_basic_data(consciousness_data, profile)\n        elif profile.data_requirement == DataRequirement.ENHANCED:\n            return self.extract_enhanced_data(consciousness_data, profile)\n        elif profile.data_requirement == DataRequirement.COMPREHENSIVE:\n            return self.extract_comprehensive_data(consciousness_data, profile)\n        elif profile.data_requirement == DataRequirement.FULL_ACCESS:\n            return consciousness_data  # ローカルサービスのみ\n            \n        return {}\n        \n    def extract_minimal_data(\n        self,\n        data: Dict[str, Any],\n        profile: MCPServiceProfile\n    ) -> Dict[str, Any]:\n        \"\"\"最小限データ抽出\"\"\"\n        \n        minimal_data = {}\n        \n        # φ値サマリー\n        if 'phi_value' in data:\n            minimal_data['phi_summary'] = {\n                'level': self.categorize_phi_value(data['phi_value']),\n                'trend': self.calculate_phi_trend(data.get('phi_history', []))\n            }\n            \n        # 発達段階レベル\n        if 'development_stage' in data:\n            minimal_data['stage_level'] = data['development_stage'].get('level', 0)\n            \n        # 匿名化が必要な場合\n        if profile.anonymization_required:\n            minimal_data = self.anonymize_data(minimal_data, profile.name)\n            \n        return minimal_data\n        \n    def extract_basic_data(\n        self,\n        data: Dict[str, Any],\n        profile: MCPServiceProfile\n    ) -> Dict[str, Any]:\n        \"\"\"基本データ抽出\"\"\"\n        \n        basic_data = self.extract_minimal_data(data, profile)\n        \n        # φ値詳細（丸め処理）\n        if 'phi_value' in data:\n            basic_data['phi_detailed'] = {\n                'current': round(data['phi_value'], 2),\n                'stability': self.calculate_phi_stability(data.get('phi_history', [])),\n                'complexity': self.categorize_phi_complexity(data['phi_value'])\n            }\n            \n        # 段階遷移情報\n        if 'stage_transitions' in data:\n            basic_data['stage_progress'] = {\n                'current_stage': data['development_stage'].get('level', 0),\n                'progress_within_stage': data.get('stage_progress', 0.0),\n                'transition_readiness': self.assess_transition_readiness(data)\n            }\n            \n        return basic_data\n        \n    def extract_enhanced_data(\n        self,\n        data: Dict[str, Any],\n        profile: MCPServiceProfile\n    ) -> Dict[str, Any]:\n        \"\"\"拡張データ抽出\"\"\"\n        \n        enhanced_data = self.extract_basic_data(data, profile)\n        \n        # 体験サマリー（匿名化済み）\n        if 'qualitative_experiences' in data:\n            enhanced_data['experience_summary'] = self.summarize_experiences(\n                data['qualitative_experiences']\n            )\n            \n        # 創造的インスピレーション用データ\n        if profile.category == MCPServiceCategory.CREATIVE_TOOLS:\n            enhanced_data['creative_cues'] = self.extract_creative_cues(data)\n            \n        # 可視化用データ\n        if 'visualization' in profile.allowed_data_types:\n            enhanced_data['visualization_data'] = self.prepare_visualization_data(data)\n            \n        return enhanced_data\n        \n    def extract_comprehensive_data(\n        self,\n        data: Dict[str, Any],\n        profile: MCPServiceProfile\n    ) -> Dict[str, Any]:\n        \"\"\"包括的データ抽出（ローカル信頼サービス用）\"\"\"\n        \n        comprehensive_data = self.extract_enhanced_data(data, profile)\n        \n        # 時間パターン（制限付き）\n        if 'temporal_consciousness' in data:\n            comprehensive_data['temporal_patterns'] = self.extract_temporal_patterns(\n                data['temporal_consciousness']\n            )\n            \n        # 行動分析データ\n        if 'behavioral_analytics' in data:\n            comprehensive_data['behavior_summary'] = self.summarize_behavior(\n                data['behavioral_analytics']\n            )\n            \n        return comprehensive_data\n        \n    def categorize_phi_value(self, phi_value: float) -> str:\n        \"\"\"φ値カテゴリ化\"\"\"\n        if phi_value < 1.0:\n            return 'minimal'\n        elif phi_value < 10.0:\n            return 'low'\n        elif phi_value < 50.0:\n            return 'moderate'\n        elif phi_value < 100.0:\n            return 'high'\n        else:\n            return 'very_high'\n            \n    def calculate_phi_trend(self, phi_history: List[float]) -> str:\n        \"\"\"φ値トレンド計算\"\"\"\n        if len(phi_history) < 2:\n            return 'stable'\n            \n        recent = phi_history[-5:]  # 直近5つ\n        if len(recent) < 2:\n            return 'stable'\n            \n        avg_change = sum(recent[i] - recent[i-1] for i in range(1, len(recent))) / (len(recent) - 1)\n        \n        if avg_change > 1.0:\n            return 'increasing'\n        elif avg_change < -1.0:\n            return 'decreasing'\n        else:\n            return 'stable'\n            \n    def anonymize_data(self, data: Dict[str, Any], service_name: str) -> Dict[str, Any]:\n        \"\"\"データ匿名化\"\"\"\n        \n        anonymized = {}\n        \n        for key, value in data.items():\n            if isinstance(value, dict):\n                anonymized[key] = self.anonymize_data(value, service_name)\n            elif isinstance(value, (int, float)):\n                # 数値データは精度を下げる\n                if isinstance(value, float):\n                    anonymized[key] = round(value, 1)\n                else:\n                    anonymized[key] = value\n            elif isinstance(value, str):\n                # 文字列データはハッシュ化\n                anonymized[key] = self.get_anonymous_id(value, service_name)\n            else:\n                anonymized[key] = value\n                \n        return anonymized\n        \n    def get_anonymous_id(self, original_value: str, service_name: str) -> str:\n        \"\"\"匿名ID生成\"\"\"\n        \n        # キャッシュチェック\n        cache_key = f\"{service_name}:{original_value}\"\n        if cache_key in self.anonymization_cache:\n            return self.anonymization_cache[cache_key]\n            \n        # ハッシュベース匿名ID生成\n        hash_input = f\"{service_name}:{original_value}:salt\"\n        anonymous_id = hashlib.sha256(hash_input.encode()).hexdigest()[:8]\n        \n        self.anonymization_cache[cache_key] = f\"anon_{anonymous_id}\"\n        return self.anonymization_cache[cache_key]\n        \n    def is_data_fresh_enough(\n        self,\n        data: Dict[str, Any],\n        profile: MCPServiceProfile\n    ) -> bool:\n        \"\"\"データ鮮度チェック\"\"\"\n        \n        if profile.max_data_age_hours is None:\n            return True\n            \n        data_timestamp = data.get('timestamp', time.time())\n        age_hours = (time.time() - data_timestamp) / 3600\n        \n        return age_hours <= profile.max_data_age_hours\n```\n\n### 3. 動的フィルタリングルール\n\n```python\nclass DynamicFilteringEngine:\n    \"\"\"動的フィルタリングエンジン\"\"\"\n    \n    def __init__(self):\n        self.filtering_rules: List[FilteringRule] = []\n        self.context_analyzers: List[ContextAnalyzer] = []\n        \n    def add_filtering_rule(self, rule: 'FilteringRule'):\n        \"\"\"フィルタリングルール追加\"\"\"\n        self.filtering_rules.append(rule)\n        \n    def apply_dynamic_filtering(\n        self,\n        data: Dict[str, Any],\n        service_profile: MCPServiceProfile,\n        context: Dict[str, Any]\n    ) -> Dict[str, Any]:\n        \"\"\"動的フィルタリング適用\"\"\"\n        \n        filtered_data = data.copy()\n        \n        # コンテキスト分析\n        enriched_context = self.analyze_context(context, service_profile)\n        \n        # ルール適用\n        for rule in self.filtering_rules:\n            if rule.applies_to_context(enriched_context):\n                filtered_data = rule.apply_filter(filtered_data, enriched_context)\n                \n        return filtered_data\n        \n    def analyze_context(self, context: Dict[str, Any], profile: MCPServiceProfile) -> Dict[str, Any]:\n        \"\"\"コンテキスト分析\"\"\"\n        \n        enriched = context.copy()\n        \n        # 時間帯分析\n        current_hour = time.localtime().tm_hour\n        enriched['time_category'] = self.categorize_time(current_hour)\n        \n        # サービス利用頻度\n        enriched['service_familiarity'] = self.assess_service_familiarity(\n            profile.name, context\n        )\n        \n        # データ感度レベル\n        enriched['data_sensitivity'] = self.assess_data_sensitivity(\n            context.get('requested_data_types', [])\n        )\n        \n        return enriched\n        \nclass FilteringRule:\n    \"\"\"フィルタリングルール基底クラス\"\"\"\n    \n    def __init__(self, name: str, priority: int = 0):\n        self.name = name\n        self.priority = priority\n        \n    def applies_to_context(self, context: Dict[str, Any]) -> bool:\n        \"\"\"コンテキスト適用判定\"\"\"\n        raise NotImplementedError\n        \n    def apply_filter(self, data: Dict[str, Any], context: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"フィルター適用\"\"\"\n        raise NotImplementedError\n        \nclass TimeBasedFilteringRule(FilteringRule):\n    \"\"\"時間ベースフィルタリングルール\"\"\"\n    \n    def __init__(self):\n        super().__init__(\"time_based_filtering\", priority=1)\n        \n    def applies_to_context(self, context: Dict[str, Any]) -> bool:\n        return 'time_category' in context\n        \n    def apply_filter(self, data: Dict[str, Any], context: Dict[str, Any]) -> Dict[str, Any]:\n        time_category = context['time_category']\n        \n        # 夜間は感度の高いデータを制限\n        if time_category == 'night':\n            filtered = {k: v for k, v in data.items() if not k.startswith('personal_')}\n            return filtered\n            \n        return data\n        \nclass FrequencyBasedFilteringRule(FilteringRule):\n    \"\"\"頻度ベースフィルタリングルール\"\"\"\n    \n    def __init__(self):\n        super().__init__(\"frequency_based_filtering\", priority=2)\n        \n    def applies_to_context(self, context: Dict[str, Any]) -> bool:\n        return 'service_familiarity' in context\n        \n    def apply_filter(self, data: Dict[str, Any], context: Dict[str, Any]) -> Dict[str, Any]:\n        familiarity = context['service_familiarity']\n        \n        # 新しいサービスは制限を強化\n        if familiarity == 'new':\n            # 基本データのみ許可\n            allowed_keys = ['phi_summary', 'stage_level']\n            filtered = {k: v for k, v in data.items() if k in allowed_keys}\n            return filtered\n            \n        return data\n```\n\n### 4. リアルタイム監視\n\n```python\nimport asyncio\nfrom collections import defaultdict, deque\n\nclass MCPDataFlowMonitor:\n    \"\"\"MCPデータフロー監視\"\"\"\n    \n    def __init__(self):\n        self.data_flows: Dict[str, deque] = defaultdict(lambda: deque(maxlen=1000))\n        self.anomaly_detectors: List['AnomalyDetector'] = []\n        self.alert_thresholds = {\n            'high_volume_requests': 100,  # 1分間に100リクエスト\n            'sensitive_data_access': 10,  # 1時間に10回の機密データアクセス\n            'failed_filters': 5,          # 5回連続のフィルター失敗\n        }\n        \n    async def log_data_flow(\n        self,\n        service_name: str,\n        data_types: List[str],\n        filtered_types: List[str],\n        context: Dict[str, Any]\n    ):\n        \"\"\"データフローログ\"\"\"\n        \n        flow_entry = {\n            'timestamp': time.time(),\n            'service_name': service_name,\n            'requested_types': data_types,\n            'provided_types': filtered_types,\n            'context': context,\n            'filter_ratio': len(filtered_types) / len(data_types) if data_types else 0\n        }\n        \n        self.data_flows[service_name].append(flow_entry)\n        \n        # 異常検知\n        await self.detect_anomalies(service_name, flow_entry)\n        \n    async def detect_anomalies(self, service_name: str, flow_entry: Dict[str, Any]):\n        \"\"\"異常検知\"\"\"\n        \n        flows = self.data_flows[service_name]\n        \n        # 高頻度リクエスト検知\n        recent_flows = [f for f in flows if time.time() - f['timestamp'] < 60]  # 1分以内\n        if len(recent_flows) > self.alert_thresholds['high_volume_requests']:\n            await self.trigger_alert(\n                'high_volume_requests',\n                f\"Service {service_name} made {len(recent_flows)} requests in 1 minute\"\n            )\n            \n        # 機密データアクセス頻度\n        sensitive_accesses = [\n            f for f in flows \n            if time.time() - f['timestamp'] < 3600  # 1時間以内\n            and any('confidential' in t for t in f['requested_types'])\n        ]\n        \n        if len(sensitive_accesses) > self.alert_thresholds['sensitive_data_access']:\n            await self.trigger_alert(\n                'sensitive_data_access',\n                f\"Service {service_name} accessed sensitive data {len(sensitive_accesses)} times in 1 hour\"\n            )\n            \n        # フィルター効果の異常\n        recent_ratios = [f['filter_ratio'] for f in list(flows)[-10:]]  # 直近10件\n        if recent_ratios and all(r < 0.1 for r in recent_ratios):  # 90%以上がフィルターされている\n            await self.trigger_alert(\n                'excessive_filtering',\n                f\"Service {service_name} is being heavily filtered (avg ratio: {sum(recent_ratios)/len(recent_ratios):.2f})\"\n            )\n            \n    async def trigger_alert(self, alert_type: str, message: str):\n        \"\"\"アラート発火\"\"\"\n        \n        print(f\"[SECURITY ALERT] {alert_type}: {message}\")\n        \n        # 必要に応じて追加のアクションを実行\n        # - ログ記録\n        # - 管理者通知\n        # - 自動制限\n        \n    def generate_flow_report(self, service_name: str = None) -> Dict[str, Any]:\n        \"\"\"フローレポート生成\"\"\"\n        \n        if service_name:\n            services = [service_name]\n        else:\n            services = list(self.data_flows.keys())\n            \n        report = {}\n        \n        for svc in services:\n            flows = list(self.data_flows[svc])\n            if not flows:\n                continue\n                \n            # 統計計算\n            total_requests = len(flows)\n            avg_filter_ratio = sum(f['filter_ratio'] for f in flows) / total_requests\n            \n            data_type_stats = defaultdict(int)\n            for flow in flows:\n                for dt in flow['provided_types']:\n                    data_type_stats[dt] += 1\n                    \n            report[svc] = {\n                'total_requests': total_requests,\n                'avg_filter_ratio': avg_filter_ratio,\n                'most_requested_types': dict(sorted(\n                    data_type_stats.items(), \n                    key=lambda x: x[1], \n                    reverse=True\n                )[:5]),\n                'time_span_hours': (flows[-1]['timestamp'] - flows[0]['timestamp']) / 3600 if flows else 0\n            }\n            \n        return report\n```\n\n### 5. 使用例とテスト\n\n```python\n# システム初期化\nclassifier = MCPServiceClassifier()\nprocessor = ConsciousnessDataProcessor(classifier)\nmonitor = MCPDataFlowMonitor()\n\n# サンプル意識データ\nconsciousness_data = {\n    'phi_value': 25.7,\n    'phi_history': [20.1, 22.3, 24.8, 25.7],\n    'development_stage': {'level': 3, 'name': 'sensorimotor'},\n    'qualitative_experiences': {\n        'visual': {'intensity': 0.8, 'complexity': 0.6},\n        'auditory': {'intensity': 0.5, 'complexity': 0.4}\n    },\n    'temporal_consciousness': {\n        'retention': ['memory1', 'memory2'],\n        'impression': {'current_focus': 'visual_input'},\n        'protention': ['expected_outcome']\n    },\n    'personal_memories': ['private_experience_1', 'private_experience_2'],\n    'timestamp': time.time()\n}\n\n# 異なるサービスでのテスト\nservices = [\n    ('localhost_viz', 'http://localhost:8080'),\n    ('photoshop_plugin', 'photoshop://local'),\n    ('anthropic_api', 'https://api.anthropic.com'),\n    ('unknown_service', 'https://suspicious-site.com')\n]\n\nfor service_name, service_url in services:\n    print(f\"\\n=== Testing {service_name} ===\")\n    \n    # データ処理\n    filtered_data = processor.process_for_service(\n        consciousness_data, service_name, service_url\n    )\n    \n    print(f\"Original keys: {list(consciousness_data.keys())}\")\n    print(f\"Filtered keys: {list(filtered_data.keys())}\")\n    print(f\"Filter ratio: {len(filtered_data) / len(consciousness_data):.2f}\")\n    \n    # 監視ログ\n    await monitor.log_data_flow(\n        service_name,\n        list(consciousness_data.keys()),\n        list(filtered_data.keys()),\n        {'user_consent': True, 'purpose': 'testing'}\n    )\n\n# 監視レポート\nreport = monitor.generate_flow_report()\nprint(\"\\n=== Data Flow Report ===\")\nfor service, stats in report.items():\n    print(f\"{service}: {stats['total_requests']} requests, {stats['avg_filter_ratio']:.2f} avg filter ratio\")\n```\n\nこのMCPデータフィルタリング戦略により、サービス特性に応じた適切なデータ保護を実現し、記憶情報の漏洩を防止できます。