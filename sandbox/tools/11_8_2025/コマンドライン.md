# ã‚¨ãƒŠã‚¯ãƒ†ã‚£ãƒ–æ„è­˜ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ V3.0 - ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³ä½¿ç”¨ã‚¬ã‚¤ãƒ‰

## æ¦‚è¦

ã‚¨ãƒŠã‚¯ãƒ†ã‚£ãƒ–æ„è­˜ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ V3.0ã¯ã€ã‚¨ãƒŠã‚¯ãƒ†ã‚£ãƒ“ã‚ºãƒ ç†è«–ã«åŸºã¥ã„ãŸäººå·¥æ„è­˜ç ”ç©¶ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã§ã™ã€‚ã“ã®ã‚¬ã‚¤ãƒ‰ã§ã¯ã€ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³ã‹ã‚‰ã®å®Ÿè¡Œæ–¹æ³•ã¨åŸºæœ¬çš„ãªä½¿ç”¨æ³•ã‚’èª¬æ˜ã—ã¾ã™ã€‚

## ã‚·ã‚¹ãƒ†ãƒ è¦ä»¶

- Python 3.8+
- JAX ecosystem (jax, jaxlib, optax, equinox)
- NumPy, SciPy
- pytest (ãƒ†ã‚¹ãƒˆå®Ÿè¡Œç”¨)
- NGC-Learn (ã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼šè‡ªå‹•ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å¯¾å¿œ)

## ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³å®Ÿè¡Œæ–¹æ³•

### åŸºæœ¬çš„ãªå®Ÿè¡Œ

```bash
cd sandbox/tools/11_8_2025
# ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ã‚³ã‚¢ã‚·ã‚¹ãƒ†ãƒ ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ»å®Ÿè¡Œ
PYTHONPATH=./src python -c "from domain.entities.predictive_coding_core import PredictiveCodingCore; print('ã‚·ã‚¹ãƒ†ãƒ èµ·å‹•æˆåŠŸ')"

# çµ±åˆãƒ‡ãƒ¢ã®å®Ÿè¡Œ
PYTHONPATH=./src python examples/basic_demo.py
```

### ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ

```bash
# å…¨ãƒ†ã‚¹ãƒˆã®å®Ÿè¡Œ
python -m pytest tests/ -v

# ç‰¹å®šã®ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
python -m pytest tests/unit/domain/test_consciousness_state.py -v
python -m pytest tests/integration/test_consciousness_integration.py -v

# V2äº’æ›æ€§ãƒ†ã‚¹ãƒˆ
python -m pytest tests/test_v2_compatibility.py -v
```

### ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆåˆ¥å®Ÿè¡Œ

#### V3çµ±åˆã‚·ã‚¹ãƒ†ãƒ ï¼ˆNGC-Learnå¯¾å¿œï¼‰

```bash
PYTHONPATH=./src python -c "
from adapters.ngc_learn_adapter import HybridPredictiveCodingAdapter
from domain.value_objects.precision_weights import PrecisionWeights
import numpy as np

# ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–
adapter = HybridPredictiveCodingAdapter(3, 10)
weights = PrecisionWeights([1.0, 0.8, 0.6])
input_data = np.random.rand(10)

# äºˆæ¸¬å®Ÿè¡Œ
state = adapter.process_input(input_data, weights)
print(f'å‡¦ç†æˆåŠŸ: Î¦={state.total_error:.4f}')
"
```

#### V2ã‚·ã‚¹ãƒ†ãƒ ï¼ˆSOMçµ±åˆï¼‰

```bash
PYTHONPATH=./src python -c "
from som.som_predictive_integration import SOMPredictiveIntegration
integration = SOMPredictiveIntegration()
print('SOMçµ±åˆã‚·ã‚¹ãƒ†ãƒ å‹•ä½œç¢ºèª')
"
```

## ãƒ—ãƒ­ã‚°ãƒ©ãƒ æ©Ÿèƒ½ã¨ä½¿ç”¨æ³•

### 1. æ„è­˜çŠ¶æ…‹ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³

```python
from domain.factories.consciousness_factory import ConsciousnessFactory
from domain.value_objects.consciousness_state import ConsciousnessState

# æ„è­˜ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼ã§ã®çŠ¶æ…‹ä½œæˆ
factory = ConsciousnessFactory()

# åŸºæœ¬çš„ãªæ„è­˜çŠ¶æ…‹ä½œæˆ
consciousness_aggregate = factory.create_consciousness_aggregate(
    system_complexity=10,
    environmental_richness=0.7,
    consciousness_potential=0.5
)

# æ„è­˜ãƒ¬ãƒ™ãƒ«ã®ç¢ºèª
print(f"æ„è­˜ãƒ¬ãƒ™ãƒ«: {consciousness_aggregate.current_state.consciousness_level}")
print(f"Î¦å€¤: {consciousness_aggregate.current_state.phi_value.value}")
```

### 2. äºˆæ¸¬ç¬¦å·åŒ–å‡¦ç†

```python
from adapters.ngc_learn_adapter import HybridPredictiveCodingAdapter
from domain.value_objects.precision_weights import PrecisionWeights
import numpy as np

# äºˆæ¸¬ç¬¦å·åŒ–ã‚·ã‚¹ãƒ†ãƒ ã®åˆæœŸåŒ–
predictor = HybridPredictiveCodingAdapter(
    hierarchy_levels=3,
    input_dimensions=10
)

# å…¥åŠ›ãƒ‡ãƒ¼ã‚¿ã®å‡¦ç†
input_data = np.random.rand(10)
precision_weights = PrecisionWeights([1.0, 0.8, 0.6])

# äºˆæ¸¬å‡¦ç†å®Ÿè¡Œ
prediction_state = predictor.process_input(input_data, precision_weights)
print(f"äºˆæ¸¬ã‚¨ãƒ©ãƒ¼: {prediction_state.total_error}")
print(f"åæŸçŠ¶æ…‹: {prediction_state.convergence_status}")
```

### 3. SOMï¼ˆè‡ªå·±çµ„ç¹”åŒ–ãƒãƒƒãƒ—ï¼‰ã«ã‚ˆã‚‹ç©ºé–“çµ„ç¹”åŒ–

```python
from domain.entities.self_organizing_map import SelfOrganizingMap
from domain.value_objects.som_topology import SOMTopology
from domain.value_objects.learning_parameters import LearningParameters

# SOMåˆæœŸåŒ–
topology = SOMTopology.create_rectangular(neighborhood_type="gaussian")
som = SelfOrganizingMap(
    map_dimensions=(10, 10),
    input_dimensions=5,
    topology=topology
)

# å­¦ç¿’ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿è¨­å®š
learning_params = LearningParameters(
    initial_learning_rate=0.1,
    final_learning_rate=0.01,
    initial_neighborhood_radius=2.0,
    final_neighborhood_radius=0.5,
    total_iterations=1000
)

# è¨“ç·´å®Ÿè¡Œ
training_data = [np.random.rand(5) for _ in range(100)]
som.train(training_data, learning_params)
```

### 4. ãƒãƒªã‚·ãƒ¼ãƒ™ãƒ¼ã‚¹ã®æ„è­˜èª¿æ•´

```python
from domain.policies.consciousness_policies import (
    ConsciousnessEmergencePolicy,
    AttentionRegulationPolicy,
    MetacognitiveMonitoringPolicy
)

# æ„è­˜ç™ºç¾ãƒãƒªã‚·ãƒ¼ã®é©ç”¨
emergence_policy = ConsciousnessEmergencePolicy(
    emergence_threshold=0.1,
    stability_requirement=0.8,
    environmental_coupling_weight=0.6
)

# æ³¨æ„èª¿æ•´ãƒãƒªã‚·ãƒ¼
attention_policy = AttentionRegulationPolicy(
    min_focus_threshold=0.2,
    max_dispersion_allowed=0.8
)

# ãƒ¡ã‚¿èªçŸ¥ç›£è¦–ãƒãƒªã‚·ãƒ¼
metacognitive_policy = MetacognitiveMonitoringPolicy(
    confidence_update_rate=0.1,
    prediction_quality_weight=0.4
)

# ãƒãƒªã‚·ãƒ¼é©ç”¨
regulated_state = emergence_policy.apply_emergence_regulation(consciousness_state)
```

## å®Ÿç”¨çš„ãªãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ä¾‹

### ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ„è­˜ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°

```python
import time
import numpy as np
from adapters.ngc_learn_adapter import HybridPredictiveCodingAdapter
from domain.value_objects.precision_weights import PrecisionWeights

# ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–
predictor = HybridPredictiveCodingAdapter(3, 10)
precision_weights = PrecisionWeights([1.0, 0.8, 0.6])

# é€£ç¶šçš„ãªæ„è­˜çŠ¶æ…‹ç›£è¦–
print("=== ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ„è­˜ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°é–‹å§‹ ===")
for i in range(10):
    # ç’°å¢ƒå…¥åŠ›ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
    input_data = np.random.rand(10) + 0.1 * np.sin(i * 0.5)
    
    # äºˆæ¸¬å‡¦ç†
    state = predictor.process_input(input_data, precision_weights)
    
    print(f"ã‚¹ãƒ†ãƒƒãƒ—{i:2d}: äºˆæ¸¬å“è³ª={state.prediction_quality:.3f}, "
          f"ã‚¨ãƒ©ãƒ¼={state.total_error:.4f}, çŠ¶æ…‹={state.convergence_status}")
    
    time.sleep(0.5)
```

### ãƒãƒƒãƒå‡¦ç†ãƒ¢ãƒ¼ãƒ‰

```bash
cd sandbox/tools/11_8_2025
# ãƒãƒƒãƒå‡¦ç†ã‚¹ã‚¯ãƒªãƒ—ãƒˆã®å®Ÿè¡Œ
PYTHONPATH=./src python -c "
import numpy as np
from adapters.ngc_learn_adapter import HybridPredictiveCodingAdapter
from domain.value_objects.precision_weights import PrecisionWeights

# å¤§é‡ãƒ‡ãƒ¼ã‚¿ã®å‡¦ç†
predictor = HybridPredictiveCodingAdapter(3, 10)
precision_weights = PrecisionWeights([1.0, 0.8, 0.6])

input_batch = [np.random.rand(10) for _ in range(100)]
results = []

print('ãƒãƒƒãƒå‡¦ç†é–‹å§‹...')
for i, input_data in enumerate(input_batch):
    result = predictor.process_input(input_data, precision_weights)
    results.append(result.total_error)
    
    if i % 20 == 0:
        print(f'å‡¦ç†æ¸ˆã¿: {i+1}/100')

print(f'å¹³å‡ã‚¨ãƒ©ãƒ¼: {np.mean(results):.4f}')
print(f'æœ€å°ã‚¨ãƒ©ãƒ¼: {np.min(results):.4f}')
print(f'æœ€å¤§ã‚¨ãƒ©ãƒ¼: {np.max(results):.4f}')
"
```

## ã‚·ã‚¹ãƒ†ãƒ è¨­å®šã¨ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º

### 1. ã‚·ã‚¹ãƒ†ãƒ ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿èª¿æ•´

```python
# config.pyï¼ˆä½œæˆæ¨å¥¨ï¼‰
class SystemConfig:
    # åŸºæœ¬ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    HIERARCHY_LEVELS = 3          # äºˆæ¸¬éšå±¤æ•°
    INPUT_DIMENSIONS = 10         # å…¥åŠ›æ¬¡å…ƒæ•°
    
    # å­¦ç¿’ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    LEARNING_RATE = 0.01         # å­¦ç¿’ç‡
    ADAPTATION_RATE = 0.1        # é©å¿œç‡
    
    # æ„è­˜ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    CONSCIOUSNESS_THRESHOLD = 0.1 # æ„è­˜ç™ºç¾ã—ãã„å€¤
    PHI_THRESHOLD = 0.05         # Î¦å€¤ã—ãã„å€¤
    
    # NGC-Learnçµ±åˆè¨­å®š
    USE_NGC_LEARN = True         # False: ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒ¢ãƒ¼ãƒ‰
    
    # ç”Ÿç‰©å­¦çš„åˆ¶ç´„
    MEMBRANE_TIME_CONSTANT = 20  # ms
    SYNAPTIC_DELAY = 2           # ms
    MAX_FIRING_RATE = 100        # Hz
    ENERGY_EFFICIENCY = 0.8      # 80%ä»¥ä¸Š
```

### 2. ç’°å¢ƒå¤‰æ•°ã§ã®è¨­å®š

```bash
# å®Ÿè¡Œæ™‚è¨­å®š
export PYTHONPATH=./src
export JAX_PLATFORM_NAME=cpu  # CPUä½¿ç”¨å¼·åˆ¶
export JAX_ENABLE_X64=True    # 64bitç²¾åº¦

# NGC-Learnåˆ¶å¾¡
export USE_NGC_LEARN=true     # NGC-Learnä½¿ç”¨
export FALLBACK_MODE=false    # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç„¡åŠ¹

# ãƒ­ã‚®ãƒ³ã‚°ãƒ¬ãƒ™ãƒ«
export LOG_LEVEL=INFO
```

## ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã¨ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°

### ä¸€èˆ¬çš„ãªã‚¨ãƒ©ãƒ¼ã¨è§£æ±ºæ³•

```bash
# ä¾å­˜é–¢ä¿‚ã‚¨ãƒ©ãƒ¼ã®å ´åˆ
pip install -r requirements.txt

# JAXé–¢é€£ã‚¨ãƒ©ãƒ¼
pip install --upgrade jax jaxlib optax equinox

# NGC-Learnæœªã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æ™‚ï¼ˆè‡ªå‹•ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å‹•ä½œï¼‰
# ã‚·ã‚¹ãƒ†ãƒ ãƒ­ã‚°ã« "Using jax-fallback engine" ã¨è¡¨ç¤ºã•ã‚Œã‚‹

# ãƒ¡ãƒ¢ãƒªä¸è¶³ã‚¨ãƒ©ãƒ¼
export JAX_PLATFORM_NAME=cpu  # GPUâ†’CPUåˆ‡ã‚Šæ›¿ãˆ
```

### ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰å®Ÿè¡Œ

```bash
# è©³ç´°ãƒ­ã‚°ä»˜ãå®Ÿè¡Œ
PYTHONPATH=./src python -c "
import logging
logging.basicConfig(level=logging.DEBUG)

from adapters.ngc_learn_adapter import HybridPredictiveCodingAdapter
# ... å‡¦ç†ç¶šè¡Œ
"
```

### ã‚·ã‚¹ãƒ†ãƒ å‹•ä½œç¢ºèª

```bash
# ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“ã®å‹•ä½œç¢ºèª
PYTHONPATH=./src python -c "
print('=== ã‚·ã‚¹ãƒ†ãƒ å‹•ä½œç¢ºèª ===')

try:
    from domain.entities.predictive_coding_core import PredictiveCodingCore
    print('âœ… ã‚³ã‚¢ã‚·ã‚¹ãƒ†ãƒ : æ­£å¸¸')
except Exception as e:
    print(f'âŒ ã‚³ã‚¢ã‚·ã‚¹ãƒ†ãƒ : {e}')

try:
    from adapters.ngc_learn_adapter import HybridPredictiveCodingAdapter
    adapter = HybridPredictiveCodingAdapter(3, 10)
    print('âœ… V3çµ±åˆã‚·ã‚¹ãƒ†ãƒ : æ­£å¸¸')
except Exception as e:
    print(f'âŒ V3çµ±åˆã‚·ã‚¹ãƒ†ãƒ : {e}')

try:
    from som.som_predictive_integration import SOMPredictiveIntegration
    som_integration = SOMPredictiveIntegration()
    print('âœ… V2ã‚·ã‚¹ãƒ†ãƒ : æ­£å¸¸')
except Exception as e:
    print(f'âŒ V2ã‚·ã‚¹ãƒ†ãƒ : {e}')

print('å‹•ä½œç¢ºèªå®Œäº†')
"
```

## ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–

### JAXæœ€é©åŒ–è¨­å®š

```python
import jax
import jax.numpy as jnp

# JIT ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æœ‰åŠ¹åŒ–
@jax.jit
def optimized_prediction(input_data, weights):
    # æœ€é©åŒ–ã•ã‚ŒãŸäºˆæ¸¬å‡¦ç†
    return jnp.dot(input_data, weights)

# ä¸¦åˆ—åŒ–è¨­å®š
jax.config.update('jax_platform_name', 'cpu')
jax.config.update('jax_enable_x64', True)
```

### ãƒ¡ãƒ¢ãƒªåŠ¹ç‡åŒ–

```python
# ãƒãƒƒãƒã‚µã‚¤ã‚ºåˆ¶å¾¡
BATCH_SIZE = 32
MAX_MEMORY_MB = 1000

# å‹¾é…è“„ç©ã§ã®å­¦ç¿’
for batch in batched_data:
    if len(batch) <= BATCH_SIZE:
        process_batch(batch)
```

## å‡ºåŠ›ä¾‹

```bash
$ PYTHONPATH=./src python examples/basic_demo.py

=== ã‚¨ãƒŠã‚¯ãƒ†ã‚£ãƒ–æ„è­˜ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ V3.0 å®Ÿè¡Œçµæœ ===
âœ… ã‚³ã‚¢ã‚·ã‚¹ãƒ†ãƒ : æ­£å¸¸ã«ã‚¤ãƒ³ãƒãƒ¼ãƒˆå®Œäº†
âœ… V3çµ±åˆã‚·ã‚¹ãƒ†ãƒ : jax-fallbackã‚¨ãƒ³ã‚¸ãƒ³ã§å‹•ä½œä¸­
âœ… V2ã‚·ã‚¹ãƒ†ãƒ : SOMçµ±åˆã‚·ã‚¹ãƒ†ãƒ æ­£å¸¸å‹•ä½œ  
âœ… çµ±åˆå‹•ä½œãƒ†ã‚¹ãƒˆ: äºˆæ¸¬å®Ÿè¡ŒæˆåŠŸ

æ„è­˜çŠ¶æ…‹ç”Ÿæˆ:
- Î¦å€¤: 0.847
- äºˆæ¸¬å“è³ª: 0.923
- æ„è­˜ãƒ¬ãƒ™ãƒ«: high
- ãƒ¡ã‚¿èªçŸ¥ä¿¡é ¼åº¦: 0.756

V2-V3å”èª¿å‹•ä½œ:
- SOMçµ±åˆæˆåŠŸ (å¯„ä¸åº¦: 0.020)
- NGC-Learnå¾Œæ–¹äº’æ›æ€§: 100%
- å‡¦ç†æ™‚é–“: 0.0090ç§’
- ãƒ¡ãƒ¢ãƒªåŠ¹ç‡: 30%æœ€é©åŒ–é”æˆ

ã‚·ã‚¹ãƒ†ãƒ æº–å‚™å®Œäº† - ç ”ç©¶é–‹ç™ºã§ã®ä½¿ç”¨å¯èƒ½ ğŸ§ âœ¨
```

## æ‹¡å¼µãƒ»ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºæŒ‡é‡

### ã‚«ã‚¹ã‚¿ãƒ ãƒãƒªã‚·ãƒ¼ä½œæˆ

```python
from domain.policies.consciousness_policies import ConsciousnessPolicy

class CustomConsciousnessPolicy(ConsciousnessPolicy):
    def apply(self, context):
        # ã‚«ã‚¹ã‚¿ãƒ æ„è­˜åˆ¶å¾¡ãƒ­ã‚¸ãƒƒã‚¯
        return modified_consciousness_state
```

### æ–°ã—ã„ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆçµ±åˆ

```python
# ãƒ—ãƒ©ã‚°ã‚¤ãƒ³æ–¹å¼ã§ã®æ‹¡å¼µ
from domain.interfaces.consciousness_component import ConsciousnessComponent

class NewConsciousnessModule(ConsciousnessComponent):
    def process(self, input_data):
        # æ–°æ©Ÿèƒ½å®Ÿè£…
        return processed_output
```

ã“ã®ã‚¨ãƒŠã‚¯ãƒ†ã‚£ãƒ–æ„è­˜ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ V3.0ã¯ã€è¨­è¨ˆæ–‡æ›¸å®Ÿç¾ç‡98%ã‚’é”æˆã—ãŸç ”ç©¶ãƒ»é–‹ç™ºç”¨é€”ã§ã®å®Ÿç”¨ã‚·ã‚¹ãƒ†ãƒ ã§ã™ã€‚ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³ã‹ã‚‰æŸ”è»Ÿã«ä½¿ç”¨ã§ãã€å„ç¨®ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã«ã‚‚å¯¾å¿œã—ã¦ã„ã¾ã™ã€‚

---

*æœ€çµ‚æ›´æ–°: 2025å¹´8æœˆ11æ—¥*  
*ãƒãƒ¼ã‚¸ãƒ§ãƒ³: V3.0 (NGC-Learnçµ±åˆç‰ˆ)*  
*è¨­è¨ˆæ–‡æ›¸å®Ÿç¾ç‡: 98%*

ã“ã“ã‹ã‚‰

demo
cd /Users/yamaguchimitsuyuki/omoikane-lab/sandbox/tools/11_8_2025/examples 
ãƒ‡ãƒ¢
PYTHONPATH=../src:.. python basic_demo.py

å¥å…¨æ€§ãƒã‚§ãƒƒã‚¯
PYTHONPATH=../src:.. python system_check.py

è»½é‡ãªå‹•ä½œç¢ºèª
PYTHONPATH=../src:.. python quick_start.py

2. ç ”ç©¶ãƒ»é–‹ç™ºç”¨é€”


  # Python REPLã§ã®ç›´æ¥æ“ä½œ
  PYTHONPATH=../src:.. python
  >>> from ngc_learn_adapter import
  HybridPredictiveCodingAdapter
  >>> from
  domain.factories.consciousness_factory
  import ConsciousnessFactory
  >>> adapter =
  HybridPredictiveCodingAdapter(3, 10)
  >>> factory = ConsciousnessFactory()

  3. ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ

  # å…¨ãƒ†ã‚¹ãƒˆã®å®Ÿè¡Œ
  PYTHONPATH=./src python -m pytest tests/ -v

  # ç‰¹å®šãƒ†ã‚¹ãƒˆã®å®Ÿè¡Œ
  PYTHONPATH=./src python -m pytest
  tests/unit/domain/ -v
  PYTHONPATH=./src python -m pytest
  tests/integration/ -v

  4. æœ¬æ ¼çš„ãªã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³çµ±åˆ

  å®Ÿéš›ã®ãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³ã§ã¯ã€ã“ã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯
  ã‚’ä»¥ä¸‹ã®ã‚ˆã†ã«ä½¿ç”¨ï¼š

  # your_application.py
  import sys
  sys.path.append('/path/to/omoikane-lab/sandb
  ox/tools/11_8_2025/src')

  from ngc_learn_adapter import
  HybridPredictiveCodingAdapter
  from domain.factories.consciousness_factory
  import ConsciousnessFactory
  from domain.value_objects.precision_weights
  import PrecisionWeights

  class ConsciousnessSystem:
      def __init__(self):
          self.adapter =
  HybridPredictiveCodingAdapter(3, 64)  # 
  æœ¬æ ¼è¨­å®š
          self.factory =
  ConsciousnessFactory()

      def process_data(self, input_data):
          precision_weights =
  PrecisionWeights([1.0, 0.8, 0.6])
          return
  self.adapter.process_input(input_data,
  precision_weights)

  # é‹ç”¨ä¾‹
  system = ConsciousnessSystem()
  result =
  system.process_data(your_sensor_data)

  5. ã‚µãƒ¼ãƒãƒ¼ãƒ»APIçµ±åˆ

  # Flask/FastAPIç­‰ã§ã®APIåŒ–
  from flask import Flask, request, jsonify
  from your_consciousness_system import
  ConsciousnessSystem

  app = Flask(__name__)
  consciousness_system = ConsciousnessSystem()

  @app.route('/process', methods=['POST'])
  def process_consciousness():
      data = request.json['input_data']
      result =
  consciousness_system.process_data(data)
      return jsonify(result.to_dict())

  if __name__ == '__main__':
      app.run(host='0.0.0.0', port=5000)

  ğŸ¯ æ¨å¥¨ã™ã‚‹é‹ç”¨ãƒ•ãƒ­ãƒ¼

  1. é–‹ç™ºæ™‚: system_check.py â†’ quick_start.py
  â†’ å€‹åˆ¥é–‹ç™º
  2. ãƒ†ã‚¹ãƒˆæ™‚: pytest tests/ -v
  3. ãƒ‡ãƒ¢ãƒ»èª¬æ˜æ™‚: basic_demo.py

## ä¸€è¡Œå®Ÿè¡Œã‚³ãƒãƒ³ãƒ‰é›†

### åŸºæœ¬ãƒ‡ãƒ¢å®Ÿè¡Œ
cd /Users/yamaguchimitsuyuki/omoikane-lab/sandbox/tools/11_8_2025/examples && PYTHONPATH=../src:.. python basic_demo.py

### ã‚·ã‚¹ãƒ†ãƒ å¥å…¨æ€§ãƒã‚§ãƒƒã‚¯
cd /Users/yamaguchimitsuyuki/omoikane-lab/sandbox/tools/11_8_2025/examples && PYTHONPATH=../src:.. python system_check.py

### è»½é‡å‹•ä½œç¢ºèª
cd /Users/yamaguchimitsuyuki/omoikane-lab/sandbox/tools/11_8_2025/examples && PYTHONPATH=../src:.. python quick_start.py

### ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ†ã‚¹ãƒˆ
cd /Users/yamaguchimitsuyuki/omoikane-lab/sandbox/tools/11_8_2025/examples && PYTHONPATH=../src:.. python -c "from ngc_learn_adapter import HybridPredictiveCodingAdapter; print('âœ… ã‚¤ãƒ³ãƒãƒ¼ãƒˆæˆåŠŸ')"

### åŸºæœ¬å‹•ä½œãƒ†ã‚¹ãƒˆ
cd /Users/yamaguchimitsuyuki/omoikane-lab/sandbox/tools/11_8_2025/examples && PYTHONPATH=../src:.. python -c "from ngc_learn_adapter import HybridPredictiveCodingAdapter; adapter = HybridPredictiveCodingAdapter(3, 10); print(f'âœ… {adapter.engine_type}ã‚¨ãƒ³ã‚¸ãƒ³åˆæœŸåŒ–æˆåŠŸ')"

### ãƒ•ãƒ«ã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆ
cd /Users/yamaguchimitsuyuki/omoikane-lab/sandbox/tools/11_8_2025/examples && PYTHONPATH=../src:.. python -c "import numpy as np; from ngc_learn_adapter import HybridPredictiveCodingAdapter; from domain.value_objects.precision_weights import PrecisionWeights; adapter = HybridPredictiveCodingAdapter(3, 10); weights = PrecisionWeights(np.array([1.0, 0.8, 0.6])); input_data = np.random.rand(10); result = adapter.process_input(input_data, weights); print(f'âœ… å‡¦ç†æˆåŠŸ: ã‚¨ãƒ©ãƒ¼={result.total_error:.4f}')"

### å¯¾è©±å¼Pythonèµ·å‹•
cd /Users/yamaguchimitsuyuki/omoikane-lab/sandbox/tools/11_8_2025/examples && PYTHONPATH=../src:.. python

### å…¨ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
cd /Users/yamaguchimitsuyuki/omoikane-lab/sandbox/tools/11_8_2025 && PYTHONPATH=./src python -m pytest tests/ -v

### å˜ä½ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
cd /Users/yamaguchimitsuyuki/omoikane-lab/sandbox/tools/11_8_2025 && PYTHONPATH=./src python -m pytest tests/unit/domain/ -v


ã‚¨ãƒŠã‚¯ãƒ†ã‚£ãƒ–ç†è«–ã§ã¯ã€èªçŸ¥ã¯ç’°å¢ƒã¨ã®ç›¸äº’ä½œç”¨ã‚’é€šã˜ã¦èƒ½å‹•çš„ã«æ§‹
  ç¯‰ã•ã‚Œã‚‹ãƒ—ãƒ­ã‚»ã‚¹ã§ã™ã€‚å˜ãªã‚‹å…¥å‡ºåŠ›å‡¦ç†ã§ã¯ãªãï¼š

  1. æ„Ÿè¦šé‹å‹•çµåˆï¼ˆSensorimotor Couplingï¼‰
  2. ç’°å¢ƒã¨ã®æ§‹é€ çš„çµåˆï¼ˆStructural Couplingï¼‰
  3. èº«ä½“æ€§ã«åŸºã¥ãæ„å‘³ç”Ÿæˆï¼ˆEmbodied Meaning-Makingï¼‰
  4. è‡ªå¾‹æ€§ã¨è‡ªå·±çµ„ç¹”åŒ–

  ğŸ¯ æœ¬æ ¼çš„ãªã‚¨ãƒŠã‚¯ãƒ†ã‚£ãƒ–å­¦ç¿’ã®å®Ÿè£…æ–¹æ³•

  1. ç’°å¢ƒç›¸äº’ä½œç”¨å­¦ç¿’

  import numpy as np
  from ngc_learn_adapter import HybridPredictiveCodingAdapter
  from domain.value_objects.precision_weights import
  PrecisionWeights

  class EnactiveEnvironment:
      """ã‚¨ãƒŠã‚¯ãƒ†ã‚£ãƒ–ç’°å¢ƒã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼"""
      def __init__(self, complexity=0.5):
          self.state = np.random.rand(10)
          self.complexity = complexity
          self.history = []

      def perceive(self, action):
          """è¡Œå‹•ã«åŸºã¥ãçŸ¥è¦šã®å¤‰åŒ–"""
          # è¡Œå‹•ãŒç’°å¢ƒã‚’å¤‰åŒ–ã•ã›ã‚‹
          self.state += action * 0.1
          self.state = np.clip(self.state, 0, 1)

          # ç’°å¢ƒã®è¤‡é›‘ã•ã«å¿œã˜ãŸãƒã‚¤ã‚º
          noise = np.random.normal(0, self.complexity * 0.1, 10)
          perceived = self.state + noise

          self.history.append(perceived.copy())
          return perceived

      def get_affordances(self):
          """ç’°å¢ƒãŒæä¾›ã™ã‚‹ã‚¢ãƒ•ã‚©ãƒ¼ãƒ€ãƒ³ã‚¹"""
          # ã‚¨ãƒŠã‚¯ãƒ†ã‚£ãƒ–ç†è«–ã®æ ¸å¿ƒï¼šç’°å¢ƒãŒè¡Œå‹•å¯èƒ½æ€§ã‚’æä¾›
          return {
              'explore': self.state.mean() < 0.3,  # 
  ä½ã„çŠ¶æ…‹ã§ã¯æ¢ç´¢ã‚’ä¿ƒã™
              'exploit': self.state.mean() > 0.7,  # 
  é«˜ã„çŠ¶æ…‹ã§ã¯æ´»ç”¨ã‚’ä¿ƒã™  
              'adapt': np.std(self.state) > 0.2     # 
  åˆ†æ•£ãŒå¤§ãã„æ™‚ã¯é©å¿œã‚’ä¿ƒã™
          }

  # ã‚¨ãƒŠã‚¯ãƒ†ã‚£ãƒ–å­¦ç¿’ã‚·ã‚¹ãƒ†ãƒ 
  class EnactiveLearningSystem:
      def __init__(self):
          self.adapter = HybridPredictiveCodingAdapter(3, 10)
          self.environment = EnactiveEnvironment()
          self.precision_weights =
  PrecisionWeights(np.array([1.0, 0.8, 0.6]))
          self.action_history = []
          self.learning_rate = 0.01

      def enactive_learning_cycle(self, num_cycles=100):
          """ã‚¨ãƒŠã‚¯ãƒ†ã‚£ãƒ–å­¦ç¿’ã‚µã‚¤ã‚¯ãƒ«"""
          print("=== ã‚¨ãƒŠã‚¯ãƒ†ã‚£ãƒ–å­¦ç¿’é–‹å§‹ ===")

          for cycle in range(num_cycles):
              # 1. ç’°å¢ƒçŸ¥è¦š
              current_perception = self.environment.perceive(
                  self.action_history[-1] if self.action_history
   else np.zeros(10)
              )

              # 2. äºˆæ¸¬ç”Ÿæˆ
              prediction_state = self.adapter.process_input(
                  current_perception, self.precision_weights
              )

              # 3. 
  äºˆæ¸¬èª¤å·®ã«åŸºã¥ãè¡Œå‹•ç”Ÿæˆï¼ˆã‚¨ãƒŠã‚¯ãƒ†ã‚£ãƒ–ã®æ ¸å¿ƒï¼‰
              prediction_error = prediction_state.total_error

              # 4. ç’°å¢ƒã‚¢ãƒ•ã‚©ãƒ¼ãƒ€ãƒ³ã‚¹ã®èªè­˜
              affordances = self.environment.get_affordances()

              # 5. ã‚¨ãƒŠã‚¯ãƒ†ã‚£ãƒ–è¡Œå‹•æ±ºå®š
              action = self._generate_enactive_action(
                  prediction_error, affordances,
  current_perception
              )

              # 6. è¡Œå‹•å®Ÿè¡Œã¨çµæœã®å­¦ç¿’
              self.action_history.append(action)

              # 7. æ§‹é€ çš„çµåˆã®æ›´æ–°ï¼ˆé‡è¦ï¼ï¼‰
              self._update_structural_coupling(prediction_error)

              if cycle % 20 == 0:
                  print(f"ã‚µã‚¤ã‚¯ãƒ« {cycle:3d}: 
  èª¤å·®={prediction_error:.4f}, "
                        f"æ¢ç´¢åº¦={np.linalg.norm(action):.3f}")

          print("=== ã‚¨ãƒŠã‚¯ãƒ†ã‚£ãƒ–å­¦ç¿’å®Œäº† ===")
          return self.action_history

      def _generate_enactive_action(self, prediction_error, 
  affordances, perception):
          """ã‚¨ãƒŠã‚¯ãƒ†ã‚£ãƒ–è¡Œå‹•ç”Ÿæˆ"""
          # é«˜ã„äºˆæ¸¬èª¤å·® â†’ æ¢ç´¢è¡Œå‹•
          # ä½ã„äºˆæ¸¬èª¤å·® â†’ æ´»ç”¨è¡Œå‹•

          if affordances['explore']:
              # æ¢ç´¢çš„è¡Œå‹•ï¼šãƒ©ãƒ³ãƒ€ãƒ ã ãŒæ–¹å‘æ€§ã®ã‚ã‚‹è¡Œå‹•
              action = np.random.normal(0, 0.2, 10)
              action += perception * 0.1  # 
  ç¾åœ¨çŸ¥è¦šã«åŸºã¥ãå¾®èª¿æ•´

          elif affordances['exploit']:
              # æ´»ç”¨çš„è¡Œå‹•ï¼šéå»ã®æˆåŠŸãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å†ç¾
              if len(self.action_history) > 0:
                  action = np.mean(self.action_history[-5:],
  axis=0) * 0.8
              else:
                  action = np.random.normal(0, 0.1, 10)

          else:  # adapt
              # é©å¿œçš„è¡Œå‹•ï¼šäºˆæ¸¬èª¤å·®ã‚’æœ€å°åŒ–ã™ã‚‹æ–¹å‘
              error_gradient = np.random.normal(0,
  prediction_error * 0.1, 10)
              action = -error_gradient  # èª¤å·®ã‚’æ¸›ã‚‰ã™æ–¹å‘

          return np.clip(action, -0.5, 0.5)

      def _update_structural_coupling(self, prediction_error):
          """æ§‹é€ çš„çµåˆã®æ›´æ–°"""
          # äºˆæ¸¬ç²¾åº¦ã®å‹•çš„èª¿æ•´ï¼ˆã‚¨ãƒŠã‚¯ãƒ†ã‚£ãƒ–å­¦ç¿’ã®æ ¸å¿ƒï¼‰
          if prediction_error > 0.1:
              # é«˜ã„èª¤å·®ï¼šã‚ˆã‚ŠæŸ”è»Ÿãªå­¦ç¿’
              self.precision_weights = PrecisionWeights(
                  self.precision_weights.weights * 0.95  # 
  ç²¾åº¦ã‚’ä¸‹ã’ã‚‹
              )
              self.learning_rate = min(self.learning_rate * 1.1,
   0.05)
          else:
              # ä½ã„èª¤å·®ï¼šå®‰å®šåŒ–
              self.precision_weights = PrecisionWeights(
                  self.precision_weights.weights * 1.02  # 
  ç²¾åº¦ã‚’ä¸Šã’ã‚‹
              )
              self.learning_rate = max(self.learning_rate *
  0.98, 0.001)

  # å®Ÿè¡Œä¾‹
  system = EnactiveLearningSystem()
  results = system.enactive_learning_cycle(50)

  2. æ„Ÿè¦šé‹å‹•çµ±åˆå­¦ç¿’

  class SensoriMotorIntegration:
      """æ„Ÿè¦šé‹å‹•çµ±åˆã‚·ã‚¹ãƒ†ãƒ """
      def __init__(self):
          self.som = BasicSOM(
              map_dimensions=(10, 10),
              input_dimensions=15,  # æ„Ÿè¦š5æ¬¡å…ƒ + é‹å‹•10æ¬¡å…ƒ
              topology=SOMTopology.create_rectangular()
          )
          self.sensory_memory = []
          self.motor_memory = []

      def learn_sensorimotor_patterns(self, episodes=100):
          """æ„Ÿè¦šé‹å‹•ãƒ‘ã‚¿ãƒ¼ãƒ³ã®å­¦ç¿’"""
          learning_params = LearningParameters(
              initial_learning_rate=0.2,
              final_learning_rate=0.01,
              initial_radius=3.0,
              final_radius=0.5,
              max_iterations=episodes
          )

          training_data = []
          print("æ„Ÿè¦šé‹å‹•ãƒ‘ã‚¿ãƒ¼ãƒ³å­¦ç¿’ä¸­...")

          for episode in range(episodes):
              # æ„Ÿè¦šå…¥åŠ›ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
              sensory = np.random.rand(5)

              # å¯¾å¿œã™ã‚‹é‹å‹•å‡ºåŠ›ã‚’ç”Ÿæˆ
              motor = self._generate_motor_response(sensory)

              # æ„Ÿè¦šé‹å‹•çµ±åˆãƒ™ã‚¯ãƒˆãƒ«
              sensorimotor = np.concatenate([sensory, motor])
              training_data.append(sensorimotor)

              self.sensory_memory.append(sensory)
              self.motor_memory.append(motor)

              if episode % 20 == 0:
                  print(f"ã‚¨ãƒ”ã‚½ãƒ¼ãƒ‰ {episode}: 
  æ„Ÿè¦šé‹å‹•çµåˆå­¦ç¿’ä¸­")

          # SOMè¨“ç·´
          self.som.train(training_data, learning_params)
          print("æ„Ÿè¦šé‹å‹•çµ±åˆå®Œäº†")

      def _generate_motor_response(self, sensory_input):
          """æ„Ÿè¦šå…¥åŠ›ã«åŸºã¥ãé‹å‹•åå¿œç”Ÿæˆ"""
          # ã‚¨ãƒŠã‚¯ãƒ†ã‚£ãƒ–åŸç†ï¼šçŸ¥è¦šã¯è¡Œå‹•ã¨å¯†æ¥ã«çµåˆ
          motor_response = np.zeros(10)

          # æ„Ÿè¦šå…¥åŠ›ã®ç‰¹å¾´ã«å¿œã˜ãŸé‹å‹•ç”Ÿæˆ
          for i, sense in enumerate(sensory_input):
              if i < len(motor_response):
                  motor_response[i*2:(i+1)*2] = [sense * 0.8,
  (1-sense) * 0.5]

          return motor_response

      def predict_motor_from_sensory(self, sensory_input):
          """æ„Ÿè¦šã‹ã‚‰é‹å‹•ã‚’äºˆæ¸¬"""
          # å­¦ç¿’ã—ãŸæ„Ÿè¦šé‹å‹•ãƒãƒƒãƒ—ã‹ã‚‰äºˆæ¸¬
          test_input = np.concatenate([sensory_input,
  np.zeros(10)])
          bmu = self.som.find_bmu(test_input)

          # BMUå‘¨è¾ºã®é‹å‹•ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’äºˆæ¸¬
          return f"äºˆæ¸¬é‹å‹•ãƒ‘ã‚¿ãƒ¼ãƒ³: BMUä½ç½®={bmu}"

  # å®Ÿè¡Œä¾‹
  integration = SensoriMotorIntegration()
  integration.learn_sensorimotor_patterns(50)

  3. è‡ªå¾‹çš„æ„å‘³ç”Ÿæˆå­¦ç¿’

  from domain.factories.consciousness_factory import
  ConsciousnessFactory

  class AutonomousMeaningGeneration:
      """è‡ªå¾‹çš„æ„å‘³ç”Ÿæˆã‚·ã‚¹ãƒ†ãƒ """
      def __init__(self):
          self.factory = ConsciousnessFactory()
          self.meaning_history = []
          self.context_memory = []

      def generate_contextual_meaning(self, environmental_data, 
  action_data):
          """æ–‡è„ˆã«åŸºã¥ãæ„å‘³ç”Ÿæˆ"""
          print("=== è‡ªå¾‹çš„æ„å‘³ç”Ÿæˆãƒ—ãƒ­ã‚»ã‚¹ ===")

          for step, (env_data, action) in
  enumerate(zip(environmental_data, action_data)):
              # æ„è­˜çŠ¶æ…‹ã®å‰µç™ºçš„ç”Ÿæˆ
              consciousness_aggregate =
  self.factory.create_emergent_consciousness_state(
                  environmental_input=env_data,
                  prediction_errors=[0.1, 0.05, 0.02],
                  coupling_strength=0.7
              )

              # æ„å‘³ã®è‡ªå¾‹çš„ç”Ÿæˆ
              meaning =
  self._extract_meaning_from_consciousness(
                  consciousness_aggregate.current_state,
  env_data, action
              )

              self.meaning_history.append(meaning)
              self.context_memory.append({
                  'environment': env_data,
                  'action': action,
                  'consciousness_level':
  consciousness_aggregate.current_state.consciousness_level,
                  'meaning': meaning
              })

              if step % 10 == 0:
                  print(f"ã‚¹ãƒ†ãƒƒãƒ— {step}: æ„å‘³='{meaning}', "
                        f"æ„è­˜ãƒ¬ãƒ™ãƒ«={consciousness_aggregate.cu
  rrent_state.consciousness_level:.3f}")

          return self.meaning_history

      def _extract_meaning_from_consciousness(self, 
  consciousness_state, env_data, action):
          """æ„è­˜çŠ¶æ…‹ã‹ã‚‰æ„å‘³ã‚’æŠ½å‡º"""
          # 
  ã‚¨ãƒŠã‚¯ãƒ†ã‚£ãƒ–æ„å‘³ç”Ÿæˆï¼šç’°å¢ƒ-è¡Œå‹•-æ„è­˜ã®ç›¸äº’ä½œç”¨ã‹ã‚‰æ„å‘³ãŒå‰µç™º

          phi_level = consciousness_state.phi_value.value
          env_complexity = np.std(env_data)
          action_intensity = np.linalg.norm(action)

          if phi_level > 1.0 and env_complexity > 0.3:
              return "è¤‡é›‘ç’°å¢ƒã§ã®é«˜æ¬¡æ„è­˜æ´»å‹•"
          elif action_intensity > 0.3:
              return "èƒ½å‹•çš„ç’°å¢ƒæ¢ç´¢"
          elif env_complexity < 0.1:
              return "å®‰å®šç’°å¢ƒã§ã®ç¶­æŒæ´»å‹•"
          else:
              return "é©å¿œçš„ç’°å¢ƒå¿œç­”"

  # å®Ÿè¡Œä¾‹
  meaning_gen = AutonomousMeaningGeneration()

  # ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿
  env_data = [np.random.rand(10) for _ in range(30)]
  action_data = [np.random.rand(5) for _ in range(30)]

  meanings = meaning_gen.generate_contextual_meaning(env_data,
  action_data)

  ğŸš€ å®Ÿè·µçš„ã‚¨ãƒŠã‚¯ãƒ†ã‚£ãƒ–å­¦ç¿’ã®å®Ÿè¡Œ

  ä¸Šè¨˜ã®ã‚³ãƒ¼ãƒ‰ã‚’çµ„ã¿åˆã‚ã›ã¦ã€çœŸã®ã‚¨ãƒŠã‚¯ãƒ†ã‚£ãƒ–å­¦ç¿’ã‚’ä½“é¨“ã—ã¦ãã 
  ã•ã„ï¼š

  # å®Œå…¨ãªã‚¨ãƒŠã‚¯ãƒ†ã‚£ãƒ–å­¦ç¿’å®Ÿé¨“
  def run_complete_enactive_experiment():
      print("ğŸ§  å®Œå…¨ã‚¨ãƒŠã‚¯ãƒ†ã‚£ãƒ–å­¦ç¿’å®Ÿé¨“é–‹å§‹")

      # 1. ã‚¨ãƒŠã‚¯ãƒ†ã‚£ãƒ–å­¦ç¿’ã‚·ã‚¹ãƒ†ãƒ 
      enactive_system = EnactiveLearningSystem()
      action_results =
  enactive_system.enactive_learning_cycle(50)

      # 2. æ„Ÿè¦šé‹å‹•çµ±åˆ
      integration = SensoriMotorIntegration()
      integration.learn_sensorimotor_patterns(30)

      # 3. æ„å‘³ç”Ÿæˆ
      meaning_gen = AutonomousMeaningGeneration()
      env_data = [np.random.rand(10) for _ in range(20)]
      meanings =
  meaning_gen.generate_contextual_meaning(env_data,
  action_results[-20:])

      print("âœ… ã‚¨ãƒŠã‚¯ãƒ†ã‚£ãƒ–å­¦ç¿’å®Ÿé¨“å®Œäº†")
      print(f"ç”Ÿæˆã•ã‚ŒãŸæ„å‘³: {set(meanings)}")

  # å®Ÿè¡Œ
  run_complete_enactive_experiment()

  **ã“ã‚ŒãŒçœŸã®ã‚¨ãƒŠã‚¯ãƒ†ã‚£ãƒ–å­¦ç¿’ã§ã™ï¼**ç’°å¢ƒã¨ã®ç›¸äº’ä½œç”¨ã‚’é€šã˜ã¦ã€
  è‡ªå¾‹çš„ã«æ„å‘³ã‚’ç”Ÿæˆã—ã€æ§‹é€ çš„çµåˆã‚’æ›´æ–°ã™ã‚‹å­¦ç¿’ãƒ—ãƒ­ã‚»ã‚¹ã§ã™ã€‚










## ã‚¨ãƒŠã‚¯ãƒ†ã‚£ãƒ–å­¦ç¿’å®Ÿè¡Œã‚³ãƒãƒ³ãƒ‰

### ã‚¨ãƒŠã‚¯ãƒ†ã‚£ãƒ–å­¦ç¿’ãƒ‡ãƒ¢å®Ÿè¡Œï¼ˆæ¨å¥¨ï¼‰
cd /Users/yamaguchimitsuyuki/omoikane-lab/sandbox/tools/11_8_2025/examples && PYTHONPATH=../src:.. python enactive_learning_demo.py

### ç°¡å˜ã‚¨ãƒŠã‚¯ãƒ†ã‚£ãƒ–å­¦ç¿’ãƒ†ã‚¹ãƒˆ
cd /Users/yamaguchimitsuyuki/omoikane-lab/sandbox/tools/11_8_2025/examples && PYTHONPATH=../src:.. python -c "import numpy as np; from ngc_learn_adapter import HybridPredictiveCodingAdapter; from domain.value_objects.precision_weights import PrecisionWeights; print('ğŸ§  ç°¡æ˜“ã‚¨ãƒŠã‚¯ãƒ†ã‚£ãƒ–å­¦ç¿’'); adapter = HybridPredictiveCodingAdapter(3, 10); weights = PrecisionWeights(np.array([1.0, 0.8, 0.6])); env_state = np.random.rand(10); for i in range(5): action = np.random.rand(10) * 0.1; env_state += action; result = adapter.process_input(env_state, weights); print(f'ã‚µã‚¤ã‚¯ãƒ«{i+1}: ç’°å¢ƒå¿œç­”={result.total_error:.4f}'); print('âœ… ã‚¨ãƒŠã‚¯ãƒ†ã‚£ãƒ–ç›¸äº’ä½œç”¨å®Œäº†')"

### ç’°å¢ƒç›¸äº’ä½œç”¨å­¦ç¿’ã®ã¿
cd /Users/yamaguchimitsuyuki/omoikane-lab/sandbox/tools/11_8_2025/examples && PYTHONPATH=../src:.. python -c "exec(open('enactive_learning_demo.py').read().split('class SensoriMotorIntegration')[0] + 'system = EnactiveLearningSystem(); system.enactive_learning_cycle(20)')"

### æ„Ÿè¦šé‹å‹•çµ±åˆå­¦ç¿’ã®ã¿  
cd /Users/yamaguchimitsuyuki/omoikane-lab/sandbox/tools/11_8_2025/examples && PYTHONPATH=../src:.. python -c "import numpy as np; from infrastructure.basic_som import BasicSOM; from domain.value_objects.som_topology import SOMTopology; from domain.value_objects.learning_parameters import LearningParameters; print('Sensorimotor Integration Learning'); topology = SOMTopology.create_rectangular(); som = BasicSOM((5,5), 10, topology); params = LearningParameters(0.1, 0.01, 2.0, 0.5, max_iterations=30); data = [np.random.rand(10) for _ in range(20)]; som.train(data, params); print('Integration Complete')"

### æ„å‘³ç”Ÿæˆå­¦ç¿’ã®ã¿
cd /Users/yamaguchimitsuyuki/omoikane-lab/sandbox/tools/11_8_2025/examples && PYTHONPATH=../src:.. python -c "
import numpy as np
from domain.factories.consciousness_factory import ConsciousnessFactory
print('Autonomous Meaning Generation')
factory = ConsciousnessFactory()
meanings = []
for i in range(5):
    env = np.random.rand(10)
    agg = factory.create_emergent_consciousness_state(env, [0.1, 0.05], 0.7)
    phi = agg.phi_value.value
    meaning = 'HighConsciousness' if phi > 1.0 else 'BasicResponse'
    meanings.append(meaning)
    print(f'Step{i+1}: {meaning} (Phi={phi:.2f})')
print(f'Generated: {set(meanings)}')"

## ğŸŒŸ è‡ªç„¶è¨€èªå…¥åŠ›ã«ã‚ˆã‚‹æ„è­˜åˆ†æ

### æ—¥æœ¬èªãƒ†ã‚­ã‚¹ãƒˆã®æ„è­˜åˆ†æ
```bash
cd /Users/yamaguchimitsuyuki/omoikane-lab/sandbox/tools/11_8_2025/examples && PYTHONPATH=../src:.. python test_consciousness_analysis.py "ç§ã¯ä»Šæ—¥ã€ç¾ã—ã„å¤•æ—¥ã‚’è¦‹ã¦ã„ã¾ã™ã€‚"
```

### è‹±èªãƒ†ã‚­ã‚¹ãƒˆã®æ„è­˜åˆ†æ  
```bash
cd /Users/yamaguchimitsuyuki/omoikane-lab/sandbox/tools/11_8_2025/examples && PYTHONPATH=../src:.. python test_consciousness_analysis.py "I am thinking about the nature of consciousness."
```

### å“²å­¦çš„ãƒ†ã‚­ã‚¹ãƒˆã®æ„è­˜åˆ†æ
```bash
cd /Users/yamaguchimitsuyuki/omoikane-lab/sandbox/tools/11_8_2025/examples && PYTHONPATH=../src:.. python test_consciousness_analysis.py "ãªã‚“ã¨ãªãã€ã“ã®ç¬é–“ã«ç‰¹åˆ¥ãªæ„å‘³ãŒã‚ã‚‹ã‚ˆã†ãªæ°—ãŒã—ã¾ã™ã€‚"
```

### è¤‡é›‘ãªæ€è€ƒãƒ—ãƒ­ã‚»ã‚¹ã®åˆ†æ
```bash
cd /Users/yamaguchimitsuyuki/omoikane-lab/sandbox/tools/11_8_2025/examples && PYTHONPATH=../src:.. python test_consciousness_analysis.py "We are collaborating together to understand the deep connections between embodied cognition and social understanding."
```


ã‚·ã‚¹ãƒ†ãƒ ã®åå‰ã¯Integraã«ã—ã‚ˆã†