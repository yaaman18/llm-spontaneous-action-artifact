# ã‚¨ãƒŠã‚¯ãƒ†ã‚£ãƒ–æ„è­˜ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ V3.0 - ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³ä½¿ç”¨ã‚¬ã‚¤ãƒ‰

## æ¦‚è¦

ã‚¨ãƒŠã‚¯ãƒ†ã‚£ãƒ–æ„è­˜ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ V3.0ã¯ã€ã‚¨ãƒŠã‚¯ãƒ†ã‚£ãƒ“ã‚ºãƒ ç†è«–ã«åŸºã¥ã„ãŸäººå·¥æ„è­˜ç ”ç©¶ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã§ã™ã€‚ã“ã®ã‚¬ã‚¤ãƒ‰ã§ã¯ã€ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³ã‹ã‚‰ã®å®Ÿè¡Œæ–¹æ³•ã¨åŸºæœ¬çš„ãªä½¿ç”¨æ³•ã‚’èª¬æ˜ã—ã¾ã™ã€‚

## ã‚·ã‚¹ãƒ†ãƒ è¦ä»¶

- Python 3.8+
- JAX ecosystem (jax, jaxlib, optax, equinox)
- NumPy, SciPy
- pytest (ãƒ†ã‚¹ãƒˆå®Ÿè¡Œç”¨)
- NGC-Learn (ã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼šè‡ªå‹•ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å¯¾å¿œ)

## ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³å®Ÿè¡Œæ–¹æ³•

### åŸºæœ¬çš„ãªå®Ÿè¡Œ

```bash
cd sandbox/tools/11_8_2025
# ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ã‚³ã‚¢ã‚·ã‚¹ãƒ†ãƒ ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ»å®Ÿè¡Œ
PYTHONPATH=./src python -c "from domain.entities.predictive_coding_core import PredictiveCodingCore; print('ã‚·ã‚¹ãƒ†ãƒ èµ·å‹•æˆåŠŸ')"

# çµ±åˆãƒ‡ãƒ¢ã®å®Ÿè¡Œ
PYTHONPATH=./src python examples/basic_demo.py
```

### ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ

```bash
# å…¨ãƒ†ã‚¹ãƒˆã®å®Ÿè¡Œ
python -m pytest tests/ -v

# ç‰¹å®šã®ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
python -m pytest tests/unit/domain/test_consciousness_state.py -v
python -m pytest tests/integration/test_consciousness_integration.py -v

# V2äº’æ›æ€§ãƒ†ã‚¹ãƒˆ
python -m pytest tests/test_v2_compatibility.py -v
```

### ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆåˆ¥å®Ÿè¡Œ

#### V3çµ±åˆã‚·ã‚¹ãƒ†ãƒ ï¼ˆNGC-Learnå¯¾å¿œï¼‰

```bash
PYTHONPATH=./src python -c "
from adapters.ngc_learn_adapter import HybridPredictiveCodingAdapter
from domain.value_objects.precision_weights import PrecisionWeights
import numpy as np

# ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–
adapter = HybridPredictiveCodingAdapter(3, 10)
weights = PrecisionWeights([1.0, 0.8, 0.6])
input_data = np.random.rand(10)

# äºˆæ¸¬å®Ÿè¡Œ
state = adapter.process_input(input_data, weights)
print(f'å‡¦ç†æˆåŠŸ: Î¦={state.total_error:.4f}')
"
```

#### V2ã‚·ã‚¹ãƒ†ãƒ ï¼ˆSOMçµ±åˆï¼‰

```bash
PYTHONPATH=./src python -c "
from som.som_predictive_integration import SOMPredictiveIntegration
integration = SOMPredictiveIntegration()
print('SOMçµ±åˆã‚·ã‚¹ãƒ†ãƒ å‹•ä½œç¢ºèª')
"
```

## ãƒ—ãƒ­ã‚°ãƒ©ãƒ æ©Ÿèƒ½ã¨ä½¿ç”¨æ³•

### 1. æ„è­˜çŠ¶æ…‹ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³

```python
from domain.factories.consciousness_factory import ConsciousnessFactory
from domain.value_objects.consciousness_state import ConsciousnessState

# æ„è­˜ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼ã§ã®çŠ¶æ…‹ä½œæˆ
factory = ConsciousnessFactory()

# åŸºæœ¬çš„ãªæ„è­˜çŠ¶æ…‹ä½œæˆ
consciousness_aggregate = factory.create_consciousness_aggregate(
    system_complexity=10,
    environmental_richness=0.7,
    consciousness_potential=0.5
)

# æ„è­˜ãƒ¬ãƒ™ãƒ«ã®ç¢ºèª
print(f"æ„è­˜ãƒ¬ãƒ™ãƒ«: {consciousness_aggregate.current_state.consciousness_level}")
print(f"Î¦å€¤: {consciousness_aggregate.current_state.phi_value.value}")
```

### 2. äºˆæ¸¬ç¬¦å·åŒ–å‡¦ç†

```python
from adapters.ngc_learn_adapter import HybridPredictiveCodingAdapter
from domain.value_objects.precision_weights import PrecisionWeights
import numpy as np

# äºˆæ¸¬ç¬¦å·åŒ–ã‚·ã‚¹ãƒ†ãƒ ã®åˆæœŸåŒ–
predictor = HybridPredictiveCodingAdapter(
    hierarchy_levels=3,
    input_dimensions=10
)

# å…¥åŠ›ãƒ‡ãƒ¼ã‚¿ã®å‡¦ç†
input_data = np.random.rand(10)
precision_weights = PrecisionWeights([1.0, 0.8, 0.6])

# äºˆæ¸¬å‡¦ç†å®Ÿè¡Œ
prediction_state = predictor.process_input(input_data, precision_weights)
print(f"äºˆæ¸¬ã‚¨ãƒ©ãƒ¼: {prediction_state.total_error}")
print(f"åæŸçŠ¶æ…‹: {prediction_state.convergence_status}")
```

### 3. SOMï¼ˆè‡ªå·±çµ„ç¹”åŒ–ãƒãƒƒãƒ—ï¼‰ã«ã‚ˆã‚‹ç©ºé–“çµ„ç¹”åŒ–

```python
from domain.entities.self_organizing_map import SelfOrganizingMap
from domain.value_objects.som_topology import SOMTopology
from domain.value_objects.learning_parameters import LearningParameters

# SOMåˆæœŸåŒ–
topology = SOMTopology.create_rectangular(neighborhood_type="gaussian")
som = SelfOrganizingMap(
    map_dimensions=(10, 10),
    input_dimensions=5,
    topology=topology
)

# å­¦ç¿’ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿è¨­å®š
learning_params = LearningParameters(
    initial_learning_rate=0.1,
    final_learning_rate=0.01,
    initial_neighborhood_radius=2.0,
    final_neighborhood_radius=0.5,
    total_iterations=1000
)

# è¨“ç·´å®Ÿè¡Œ
training_data = [np.random.rand(5) for _ in range(100)]
som.train(training_data, learning_params)
```

### 4. ãƒãƒªã‚·ãƒ¼ãƒ™ãƒ¼ã‚¹ã®æ„è­˜èª¿æ•´

```python
from domain.policies.consciousness_policies import (
    ConsciousnessEmergencePolicy,
    AttentionRegulationPolicy,
    MetacognitiveMonitoringPolicy
)

# æ„è­˜ç™ºç¾ãƒãƒªã‚·ãƒ¼ã®é©ç”¨
emergence_policy = ConsciousnessEmergencePolicy(
    emergence_threshold=0.1,
    stability_requirement=0.8,
    environmental_coupling_weight=0.6
)

# æ³¨æ„èª¿æ•´ãƒãƒªã‚·ãƒ¼
attention_policy = AttentionRegulationPolicy(
    min_focus_threshold=0.2,
    max_dispersion_allowed=0.8
)

# ãƒ¡ã‚¿èªçŸ¥ç›£è¦–ãƒãƒªã‚·ãƒ¼
metacognitive_policy = MetacognitiveMonitoringPolicy(
    confidence_update_rate=0.1,
    prediction_quality_weight=0.4
)

# ãƒãƒªã‚·ãƒ¼é©ç”¨
regulated_state = emergence_policy.apply_emergence_regulation(consciousness_state)
```

## å®Ÿç”¨çš„ãªãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ä¾‹

### ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ„è­˜ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°

```python
import time
import numpy as np
from adapters.ngc_learn_adapter import HybridPredictiveCodingAdapter
from domain.value_objects.precision_weights import PrecisionWeights

# ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–
predictor = HybridPredictiveCodingAdapter(3, 10)
precision_weights = PrecisionWeights([1.0, 0.8, 0.6])

# é€£ç¶šçš„ãªæ„è­˜çŠ¶æ…‹ç›£è¦–
print("=== ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ„è­˜ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°é–‹å§‹ ===")
for i in range(10):
    # ç’°å¢ƒå…¥åŠ›ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
    input_data = np.random.rand(10) + 0.1 * np.sin(i * 0.5)
    
    # äºˆæ¸¬å‡¦ç†
    state = predictor.process_input(input_data, precision_weights)
    
    print(f"ã‚¹ãƒ†ãƒƒãƒ—{i:2d}: äºˆæ¸¬å“è³ª={state.prediction_quality:.3f}, "
          f"ã‚¨ãƒ©ãƒ¼={state.total_error:.4f}, çŠ¶æ…‹={state.convergence_status}")
    
    time.sleep(0.5)
```

### ãƒãƒƒãƒå‡¦ç†ãƒ¢ãƒ¼ãƒ‰

```bash
cd sandbox/tools/11_8_2025
# ãƒãƒƒãƒå‡¦ç†ã‚¹ã‚¯ãƒªãƒ—ãƒˆã®å®Ÿè¡Œ
PYTHONPATH=./src python -c "
import numpy as np
from adapters.ngc_learn_adapter import HybridPredictiveCodingAdapter
from domain.value_objects.precision_weights import PrecisionWeights

# å¤§é‡ãƒ‡ãƒ¼ã‚¿ã®å‡¦ç†
predictor = HybridPredictiveCodingAdapter(3, 10)
precision_weights = PrecisionWeights([1.0, 0.8, 0.6])

input_batch = [np.random.rand(10) for _ in range(100)]
results = []

print('ãƒãƒƒãƒå‡¦ç†é–‹å§‹...')
for i, input_data in enumerate(input_batch):
    result = predictor.process_input(input_data, precision_weights)
    results.append(result.total_error)
    
    if i % 20 == 0:
        print(f'å‡¦ç†æ¸ˆã¿: {i+1}/100')

print(f'å¹³å‡ã‚¨ãƒ©ãƒ¼: {np.mean(results):.4f}')
print(f'æœ€å°ã‚¨ãƒ©ãƒ¼: {np.min(results):.4f}')
print(f'æœ€å¤§ã‚¨ãƒ©ãƒ¼: {np.max(results):.4f}')
"
```

## ã‚·ã‚¹ãƒ†ãƒ è¨­å®šã¨ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º

### 1. ã‚·ã‚¹ãƒ†ãƒ ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿èª¿æ•´

```python
# config.pyï¼ˆä½œæˆæ¨å¥¨ï¼‰
class SystemConfig:
    # åŸºæœ¬ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    HIERARCHY_LEVELS = 3          # äºˆæ¸¬éšå±¤æ•°
    INPUT_DIMENSIONS = 10         # å…¥åŠ›æ¬¡å…ƒæ•°
    
    # å­¦ç¿’ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    LEARNING_RATE = 0.01         # å­¦ç¿’ç‡
    ADAPTATION_RATE = 0.1        # é©å¿œç‡
    
    # æ„è­˜ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    CONSCIOUSNESS_THRESHOLD = 0.1 # æ„è­˜ç™ºç¾ã—ãã„å€¤
    PHI_THRESHOLD = 0.05         # Î¦å€¤ã—ãã„å€¤
    
    # NGC-Learnçµ±åˆè¨­å®š
    USE_NGC_LEARN = True         # False: ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒ¢ãƒ¼ãƒ‰
    
    # ç”Ÿç‰©å­¦çš„åˆ¶ç´„
    MEMBRANE_TIME_CONSTANT = 20  # ms
    SYNAPTIC_DELAY = 2           # ms
    MAX_FIRING_RATE = 100        # Hz
    ENERGY_EFFICIENCY = 0.8      # 80%ä»¥ä¸Š
```

### 2. ç’°å¢ƒå¤‰æ•°ã§ã®è¨­å®š

```bash
# å®Ÿè¡Œæ™‚è¨­å®š
export PYTHONPATH=./src
export JAX_PLATFORM_NAME=cpu  # CPUä½¿ç”¨å¼·åˆ¶
export JAX_ENABLE_X64=True    # 64bitç²¾åº¦

# NGC-Learnåˆ¶å¾¡
export USE_NGC_LEARN=true     # NGC-Learnä½¿ç”¨
export FALLBACK_MODE=false    # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç„¡åŠ¹

# ãƒ­ã‚®ãƒ³ã‚°ãƒ¬ãƒ™ãƒ«
export LOG_LEVEL=INFO
```

## ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã¨ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°

### ä¸€èˆ¬çš„ãªã‚¨ãƒ©ãƒ¼ã¨è§£æ±ºæ³•

```bash
# ä¾å­˜é–¢ä¿‚ã‚¨ãƒ©ãƒ¼ã®å ´åˆ
pip install -r requirements.txt

# JAXé–¢é€£ã‚¨ãƒ©ãƒ¼
pip install --upgrade jax jaxlib optax equinox

# NGC-Learnæœªã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æ™‚ï¼ˆè‡ªå‹•ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å‹•ä½œï¼‰
# ã‚·ã‚¹ãƒ†ãƒ ãƒ­ã‚°ã« "Using jax-fallback engine" ã¨è¡¨ç¤ºã•ã‚Œã‚‹

# ãƒ¡ãƒ¢ãƒªä¸è¶³ã‚¨ãƒ©ãƒ¼
export JAX_PLATFORM_NAME=cpu  # GPUâ†’CPUåˆ‡ã‚Šæ›¿ãˆ
```

### ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰å®Ÿè¡Œ

```bash
# è©³ç´°ãƒ­ã‚°ä»˜ãå®Ÿè¡Œ
PYTHONPATH=./src python -c "
import logging
logging.basicConfig(level=logging.DEBUG)

from adapters.ngc_learn_adapter import HybridPredictiveCodingAdapter
# ... å‡¦ç†ç¶šè¡Œ
"
```

### ã‚·ã‚¹ãƒ†ãƒ å‹•ä½œç¢ºèª

```bash
# ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“ã®å‹•ä½œç¢ºèª
PYTHONPATH=./src python -c "
print('=== ã‚·ã‚¹ãƒ†ãƒ å‹•ä½œç¢ºèª ===')

try:
    from domain.entities.predictive_coding_core import PredictiveCodingCore
    print('âœ… ã‚³ã‚¢ã‚·ã‚¹ãƒ†ãƒ : æ­£å¸¸')
except Exception as e:
    print(f'âŒ ã‚³ã‚¢ã‚·ã‚¹ãƒ†ãƒ : {e}')

try:
    from adapters.ngc_learn_adapter import HybridPredictiveCodingAdapter
    adapter = HybridPredictiveCodingAdapter(3, 10)
    print('âœ… V3çµ±åˆã‚·ã‚¹ãƒ†ãƒ : æ­£å¸¸')
except Exception as e:
    print(f'âŒ V3çµ±åˆã‚·ã‚¹ãƒ†ãƒ : {e}')

try:
    from som.som_predictive_integration import SOMPredictiveIntegration
    som_integration = SOMPredictiveIntegration()
    print('âœ… V2ã‚·ã‚¹ãƒ†ãƒ : æ­£å¸¸')
except Exception as e:
    print(f'âŒ V2ã‚·ã‚¹ãƒ†ãƒ : {e}')

print('å‹•ä½œç¢ºèªå®Œäº†')
"
```

## ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–

### JAXæœ€é©åŒ–è¨­å®š

```python
import jax
import jax.numpy as jnp

# JIT ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æœ‰åŠ¹åŒ–
@jax.jit
def optimized_prediction(input_data, weights):
    # æœ€é©åŒ–ã•ã‚ŒãŸäºˆæ¸¬å‡¦ç†
    return jnp.dot(input_data, weights)

# ä¸¦åˆ—åŒ–è¨­å®š
jax.config.update('jax_platform_name', 'cpu')
jax.config.update('jax_enable_x64', True)
```

### ãƒ¡ãƒ¢ãƒªåŠ¹ç‡åŒ–

```python
# ãƒãƒƒãƒã‚µã‚¤ã‚ºåˆ¶å¾¡
BATCH_SIZE = 32
MAX_MEMORY_MB = 1000

# å‹¾é…è“„ç©ã§ã®å­¦ç¿’
for batch in batched_data:
    if len(batch) <= BATCH_SIZE:
        process_batch(batch)
```

## å‡ºåŠ›ä¾‹

```bash
$ PYTHONPATH=./src python examples/basic_demo.py

=== ã‚¨ãƒŠã‚¯ãƒ†ã‚£ãƒ–æ„è­˜ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ V3.0 å®Ÿè¡Œçµæœ ===
âœ… ã‚³ã‚¢ã‚·ã‚¹ãƒ†ãƒ : æ­£å¸¸ã«ã‚¤ãƒ³ãƒãƒ¼ãƒˆå®Œäº†
âœ… V3çµ±åˆã‚·ã‚¹ãƒ†ãƒ : jax-fallbackã‚¨ãƒ³ã‚¸ãƒ³ã§å‹•ä½œä¸­
âœ… V2ã‚·ã‚¹ãƒ†ãƒ : SOMçµ±åˆã‚·ã‚¹ãƒ†ãƒ æ­£å¸¸å‹•ä½œ  
âœ… çµ±åˆå‹•ä½œãƒ†ã‚¹ãƒˆ: äºˆæ¸¬å®Ÿè¡ŒæˆåŠŸ

æ„è­˜çŠ¶æ…‹ç”Ÿæˆ:
- Î¦å€¤: 0.847
- äºˆæ¸¬å“è³ª: 0.923
- æ„è­˜ãƒ¬ãƒ™ãƒ«: high
- ãƒ¡ã‚¿èªçŸ¥ä¿¡é ¼åº¦: 0.756

V2-V3å”èª¿å‹•ä½œ:
- SOMçµ±åˆæˆåŠŸ (å¯„ä¸åº¦: 0.020)
- NGC-Learnå¾Œæ–¹äº’æ›æ€§: 100%
- å‡¦ç†æ™‚é–“: 0.0090ç§’
- ãƒ¡ãƒ¢ãƒªåŠ¹ç‡: 30%æœ€é©åŒ–é”æˆ

ã‚·ã‚¹ãƒ†ãƒ æº–å‚™å®Œäº† - ç ”ç©¶é–‹ç™ºã§ã®ä½¿ç”¨å¯èƒ½ ğŸ§ âœ¨
```

## æ‹¡å¼µãƒ»ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºæŒ‡é‡

### ã‚«ã‚¹ã‚¿ãƒ ãƒãƒªã‚·ãƒ¼ä½œæˆ

```python
from domain.policies.consciousness_policies import ConsciousnessPolicy

class CustomConsciousnessPolicy(ConsciousnessPolicy):
    def apply(self, context):
        # ã‚«ã‚¹ã‚¿ãƒ æ„è­˜åˆ¶å¾¡ãƒ­ã‚¸ãƒƒã‚¯
        return modified_consciousness_state
```

### æ–°ã—ã„ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆçµ±åˆ

```python
# ãƒ—ãƒ©ã‚°ã‚¤ãƒ³æ–¹å¼ã§ã®æ‹¡å¼µ
from domain.interfaces.consciousness_component import ConsciousnessComponent

class NewConsciousnessModule(ConsciousnessComponent):
    def process(self, input_data):
        # æ–°æ©Ÿèƒ½å®Ÿè£…
        return processed_output
```

ã“ã®ã‚¨ãƒŠã‚¯ãƒ†ã‚£ãƒ–æ„è­˜ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ V3.0ã¯ã€è¨­è¨ˆæ–‡æ›¸å®Ÿç¾ç‡98%ã‚’é”æˆã—ãŸç ”ç©¶ãƒ»é–‹ç™ºç”¨é€”ã§ã®å®Ÿç”¨ã‚·ã‚¹ãƒ†ãƒ ã§ã™ã€‚ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³ã‹ã‚‰æŸ”è»Ÿã«ä½¿ç”¨ã§ãã€å„ç¨®ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã«ã‚‚å¯¾å¿œã—ã¦ã„ã¾ã™ã€‚

---

*æœ€çµ‚æ›´æ–°: 2025å¹´8æœˆ11æ—¥*  
*ãƒãƒ¼ã‚¸ãƒ§ãƒ³: V3.0 (NGC-Learnçµ±åˆç‰ˆ)*  
*è¨­è¨ˆæ–‡æ›¸å®Ÿç¾ç‡: 98%*