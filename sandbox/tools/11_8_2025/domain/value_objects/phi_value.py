"""
Phi (Φ) Value Object.

Immutable representation of integrated information (Φ) as defined in
Integrated Information Theory (IIT). Represents the amount of integrated
information generated by a conscious system.
"""

from dataclasses import dataclass, field
from typing import Dict, Any, Optional, Tuple
import math


@dataclass(frozen=True)
class PhiValue:
    """
    Immutable representation of integrated information (Φ).
    
    Based on Integrated Information Theory (IIT), Φ quantifies the
    amount of integrated information generated by a system above
    and beyond its parts when taken independently.
    """
    
    value: float
    complexity: float
    integration: float
    system_size: int = field(default=1)
    computation_method: str = field(default="approximate")
    confidence: float = field(default=1.0)
    metadata: Dict[str, Any] = field(default_factory=dict, hash=False)
    
    def __post_init__(self) -> None:
        """Validate Φ value after initialization."""
        self._validate_phi_value()
        self._validate_complexity()
        self._validate_integration() 
        self._validate_system_size()
        self._validate_confidence()
        self._validate_computation_method()

    def _validate_phi_value(self) -> None:
        """Validate Φ value is non-negative."""
        if self.value < 0:
            raise ValueError("Φ value must be non-negative")
        if math.isnan(self.value) or math.isinf(self.value):
            raise ValueError("Φ value must be finite")

    def _validate_complexity(self) -> None:
        """Validate complexity component."""
        if self.complexity < 0:
            raise ValueError("Complexity must be non-negative")
        if math.isnan(self.complexity) or math.isinf(self.complexity):
            raise ValueError("Complexity must be finite")

    def _validate_integration(self) -> None:
        """Validate integration component."""
        if self.integration < 0:
            raise ValueError("Integration must be non-negative")
        if math.isnan(self.integration) or math.isinf(self.integration):
            raise ValueError("Integration must be finite")

    def _validate_system_size(self) -> None:
        """Validate system size."""
        if self.system_size < 1:
            raise ValueError("System size must be positive")

    def _validate_confidence(self) -> None:
        """Validate confidence level."""
        if not (0.0 <= self.confidence <= 1.0):
            raise ValueError("Confidence must be in [0, 1]")

    def _validate_computation_method(self) -> None:
        """Validate computation method."""
        valid_methods = {"exact", "approximate", "heuristic", "empirical"}
        if self.computation_method not in valid_methods:
            raise ValueError(f"Invalid computation method: {self.computation_method}")

    @property
    def is_conscious(self) -> bool:
        """Check if Φ value indicates consciousness (Φ > 0)."""
        return self.value > 0.0

    @property
    def normalized_value(self) -> float:
        """
        Normalize Φ value relative to system size.
        
        Returns:
            Φ value normalized by system size
        """
        return self.value / max(self.system_size, 1)

    @property
    def consciousness_level(self) -> str:
        """
        Categorize consciousness level based on Φ value.
        
        Returns:
            String description of consciousness level
        """
        if self.value <= 0.0:
            return "unconscious"
        elif self.value <= 0.1:
            return "minimal"
        elif self.value <= 1.0:
            return "moderate"
        elif self.value <= 5.0:
            return "high"
        else:
            return "very_high"

    @property
    def integration_complexity_ratio(self) -> float:
        """
        Ratio of integration to complexity.
        
        Measures how well integrated the system is relative to its complexity.
        Higher values indicate better integration.
        
        Returns:
            Integration/complexity ratio
        """
        if self.complexity == 0.0:
            return 0.0
        return self.integration / self.complexity

    @property
    def theoretical_maximum(self) -> float:
        """
        Theoretical maximum Φ for the given system size.
        
        Based on IIT theoretical bounds for integrated information.
        
        Returns:
            Theoretical maximum Φ value
        """
        # Simplified theoretical bound based on system size
        return self.system_size * math.log2(self.system_size) if self.system_size > 1 else 1.0

    @property
    def efficiency(self) -> float:
        """
        Efficiency of integration (Φ / theoretical maximum).
        
        Returns:
            Integration efficiency [0, 1]
        """
        theoretical_max = self.theoretical_maximum
        if theoretical_max == 0.0:
            return 0.0
        return min(self.value / theoretical_max, 1.0)

    def compare_with(self, other: 'PhiValue') -> Dict[str, float]:
        """
        Compare this Φ value with another.
        
        Args:
            other: Another PhiValue to compare with
            
        Returns:
            Dictionary with comparison metrics
        """
        return {
            "phi_difference": round(self.value - other.value, 10),
            "phi_ratio": self.value / max(other.value, 1e-10),
            "complexity_difference": round(self.complexity - other.complexity, 10),
            "integration_difference": round(self.integration - other.integration, 10),
            "efficiency_difference": self.efficiency - other.efficiency,
            "consciousness_level_same": self.consciousness_level == other.consciousness_level
        }

    def with_updated_value(self, new_value: float) -> 'PhiValue':
        """
        Create new PhiValue with updated Φ value.
        
        Args:
            new_value: New Φ value
            
        Returns:
            New PhiValue instance with updated value
        """
        return PhiValue(
            value=new_value,
            complexity=self.complexity,
            integration=self.integration,
            system_size=self.system_size,
            computation_method=self.computation_method,
            confidence=self.confidence,
            metadata=self.metadata.copy()
        )

    def with_updated_components(
        self, 
        new_complexity: Optional[float] = None,
        new_integration: Optional[float] = None
    ) -> 'PhiValue':
        """
        Create new PhiValue with updated complexity and/or integration.
        
        Args:
            new_complexity: New complexity value (if provided)
            new_integration: New integration value (if provided)
            
        Returns:
            New PhiValue instance with updated components
        """
        complexity = new_complexity if new_complexity is not None else self.complexity
        integration = new_integration if new_integration is not None else self.integration
        
        # Recalculate Φ based on updated components
        # This is a simplified calculation - actual IIT computation is more complex
        new_phi = complexity * integration
        
        return PhiValue(
            value=new_phi,
            complexity=complexity,
            integration=integration,
            system_size=self.system_size,
            computation_method=self.computation_method,
            confidence=self.confidence,
            metadata=self.metadata.copy()
        )

    def add_metadata(self, key: str, value: Any) -> 'PhiValue':
        """
        Add metadata to the Φ value.
        
        Args:
            key: Metadata key
            value: Metadata value
            
        Returns:
            New PhiValue with added metadata
        """
        new_metadata = self.metadata.copy()
        new_metadata[key] = value
        
        return PhiValue(
            value=self.value,
            complexity=self.complexity,
            integration=self.integration,
            system_size=self.system_size,
            computation_method=self.computation_method,
            confidence=self.confidence,
            metadata=new_metadata
        )

    def to_dict(self) -> Dict[str, Any]:
        """
        Convert Φ value to dictionary representation.
        
        Returns:
            Dictionary representation suitable for serialization
        """
        return {
            "value": self.value,
            "complexity": self.complexity,
            "integration": self.integration,
            "system_size": self.system_size,
            "computation_method": self.computation_method,
            "confidence": self.confidence,
            "metadata": self.metadata,
            "is_conscious": self.is_conscious,
            "normalized_value": self.normalized_value,
            "consciousness_level": self.consciousness_level,
            "integration_complexity_ratio": self.integration_complexity_ratio,
            "theoretical_maximum": self.theoretical_maximum,
            "efficiency": self.efficiency
        }

    @classmethod
    def create_zero(cls) -> 'PhiValue':
        """
        Create a zero Φ value (unconscious state).
        
        Returns:
            PhiValue representing unconscious state
        """
        return cls(
            value=0.0,
            complexity=0.0,
            integration=0.0,
            system_size=1,
            computation_method="exact",
            confidence=1.0,
            metadata={"state": "unconscious"}
        )

    @classmethod
    def create_minimal(cls, system_size: int = 1) -> 'PhiValue':
        """
        Create minimal consciousness Φ value.
        
        Args:
            system_size: Size of the conscious system
            
        Returns:
            PhiValue representing minimal consciousness
        """
        return cls(
            value=0.1,
            complexity=0.2,
            integration=0.5,
            system_size=system_size,
            computation_method="approximate",
            confidence=0.8,
            metadata={"state": "minimal_consciousness"}
        )